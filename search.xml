<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组队列</title>
    <url>/2024/08/19/ArrayQueue/</url>
    <content><![CDATA[<h1>数组队列</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——数组队列</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>队列是一个有序列表，可以用数组或链表实现。</li>
<li>遵循先入先出原则：
<ul>
<li>先存入的数据，先取出，后存入的数据后取出。</li>
</ul>
</li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>使用数组模拟队列实现</li>
<li>相关数据：
<ul>
<li><strong>maxSize</strong>：该队列的最大容量</li>
<li><strong>front</strong>：头指针，指向队列头部，指向队列头的前一个位置，随数据的输出而改变，初始值为-1</li>
<li><strong>rear</strong>： 尾指针，指向队列尾部，指向队列尾，随数据的输入而改变，初始值为-1</li>
</ul>
</li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li>
<p>创建 ArrayQueue类</p>
<ul>
<li>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//存储队列的数组</span></span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span>{</span><br><span class="line">    maxSize = arrMaxSize;</span><br><span class="line">    arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    front = -<span class="number">1</span>;<span class="comment">//指向队列头部，指向队列头的前一个位置</span></span><br><span class="line">    rear = -<span class="number">1</span>;<span class="comment">// 指向队列尾部，指向队列尾</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>addQueue方法：将数据存入队列中</strong></p>
<ul>
<li>
<p>思路分析：</p>
<ul>
<li>
<p>rear == front 时队列为空</p>
</li>
<li>
<p>将尾指针往后移：rear+1</p>
</li>
<li>
<p>rear == maxSize-1时 队列满不能再添加数据</p>
</li>
<li>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">      <span class="comment">//判断队列是否满</span></span><br><span class="line">      <span class="keyword">if</span>(isFull()){</span><br><span class="line">          System.out.println(<span class="string">"队列满了，不能再添加数据"</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      }</span><br><span class="line">      arr[++rear] = n;<span class="comment">//先对rear+1，再进行赋值</span></span><br><span class="line">  }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>isFull方法： 判断队列是否满</p>
<ul>
<li>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> rear == maxSize-<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>isEmpty方法： 判断队列是否空</p>
<ul>
<li>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> rear == front;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>getQueue方法：获取队列,出队列</p>
<ul>
<li>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>{</span><br><span class="line">     <span class="comment">//判断队列是否为空</span></span><br><span class="line">     <span class="keyword">if</span>(isEmpty()){</span><br><span class="line">         <span class="comment">//抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">     }</span><br><span class="line">     front++;<span class="comment">//后移</span></span><br><span class="line">     <span class="keyword">return</span> arr[front];</span><br><span class="line"> }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>showQueue方法：显示队列所有数据</p>
<ul>
<li>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()){</span><br><span class="line">        System.out.println(<span class="string">"队列空没有数据"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; arr.length;i++) {</span><br><span class="line">        System.out.printf(<span class="string">"arr[%d]=%d\n"</span>,i,arr[i]);</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>headQueue方法： 显示队列头数据</p>
<ul>
<li>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"队列空没有数据"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>主类ArrayQueueDemo方法： 测试</p>
<ul>
<li>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">' '</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop){</span><br><span class="line">            System.out.println(<span class="string">"s(show):"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit):"</span>);</span><br><span class="line">            System.out.println(<span class="string">"a(add):"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get):"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head):"</span>);</span><br><span class="line">            key =scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span>(key){</span><br><span class="line">                <span class="keyword">case</span><span class="string">'s'</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">'a'</span>:</span><br><span class="line">                    System.out.print(<span class="string">"请输入一个数："</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span>{</span><br><span class="line">                     <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"取出的数据是%d\n"</span>,res);</span><br><span class="line">                    }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span>{</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"队列头的数据是%d\n"</span>,res);</span><br><span class="line">                    }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">'e'</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"退出"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li>
<p>addQueue方法：</p>
<p><img src="/2024/08/19/ArrayQueue/01.png" alt></p>
</li>
<li>
<p>showQueue方法：</p>
<p><img src="/2024/08/19/ArrayQueue/02.png" alt></p>
</li>
<li>
<p>headQueue方法：</p>
<p><img src="/2024/08/19/ArrayQueue/03.png" alt></p>
</li>
<li>
<p>getQueue方法：</p>
<p><img src="/2024/08/19/ArrayQueue/04.png" alt></p>
</li>
<li>
<p>exit方法：</p>
<p><img src="/2024/08/19/ArrayQueue/05.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰表达式求值</title>
    <url>/2026/01/29/EvaluateAReversePolishNotationExpression/</url>
    <content><![CDATA[<h1>算法-逆波兰表达式求值</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–逆波兰表达式求值</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：</p>
<ul>
<li>输入: [“2”, “1”, “+”, “3”, " * "]</li>
<li>输出: 9</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入: [“4”, “13”, “5”, “/”, “+”]</li>
<li>输出: 6</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</li>
</ul>
<p>示例 3：</p>
<ul>
<li>
<p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, " * ", “/”, " * ", “17”, “+”, “5”, “+”]</p>
</li>
<li>
<p>输出: 22</p>
</li>
<li>
<p>解释:该算式转化为常见的中缀算术表达式为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">((10 * (6 / ((9 + 3) * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="line">= ((10 * 0) + 17) + 5     </span><br><span class="line">= (0 + 17) + 5    </span><br><span class="line">= 17 + 5    </span><br><span class="line">= 22    </span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</p>
<p>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><strong>核心逻辑：<strong>逆波兰表达式（后缀表达式）的计算天然适配</strong>栈的「后进先出」特性</strong>—— 数字入栈，运算符取出栈顶两个数字计算，结果重新入栈，最终栈中仅剩一个元素（表达式结果）；</li>
<li><strong>具体步骤：</strong>
<ul>
<li>初始化栈，遍历逆波兰表达式的每个元素：
<ul>
<li>若为数字 → 转为整数压入栈；</li>
<li>若为运算符 → 取出栈顶两个数字（注意顺序：后弹出的是「被操作数」，先弹出的是「操作数」），执行运算后将结果压入栈；</li>
</ul>
</li>
<li>遍历结束后，栈中唯一元素即为表达式的计算结果。</li>
</ul>
</li>
<li><strong>关键注意事项：</strong>
<ul>
<li>减法：栈顶第一个数是减数，第二个数是被减数 → 计算 <code>被减数 - 减数</code>；</li>
<li>除法：栈顶第一个数是除数，第二个数是被除数 → 计算 <code>被除数 / 除数</code>；</li>
<li>整数除法：题目要求保留整数部分，Java 中整数除法会自动向下取整（符合题目要求）。</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">        <span class="comment">// 用Deque模拟栈（推荐LinkedList/ArrayDeque，效率高于Stack）</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">// 遍历逆波兰表达式的每个元素</span></span><br><span class="line">        <span class="keyword">for</span>(String s : tokens){</span><br><span class="line">            <span class="comment">// 加法：取出栈顶两个数，求和后压入</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"+"</span>.equals(s)){</span><br><span class="line">                stack.push(stack.pop()+stack.pop());</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(s)){</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(s)){</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/"</span>.equals(s)){</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop(); <span class="comment">// 除数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();<span class="comment">// 被除数</span></span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><strong>核心知识点：</strong>
<ul>
<li>**栈的经典应用：**逆波兰表达式的计算是栈的「标志性场景」—— 运算符作用于「最近的两个数字」，栈顶正好是最近入栈的数字，完美适配；</li>
<li>**运算顺序是关键：**减法 / 除法必须注意「被操作数和操作数的顺序」（先弹出的是操作数，后弹出的是被操作数），这是面试最高频的坑；</li>
<li>**效率优势：**逆波兰表达式无需处理括号和运算符优先级，仅需一次遍历（O (n)）即可完成计算，是编译器处理表达式的核心思路。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>逆波兰表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>四数相加</title>
    <url>/2026/01/19/FourSumII/</url>
    <content><![CDATA[<h1>算法-四数相加</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–四数相加</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p>
<p><strong>例如:</strong></p>
<p>输入:</p>
<ul>
<li>A = [ 1, 2]</li>
<li>B = [-2,-1]</li>
<li>C = [-1, 2]</li>
<li>D = [ 0, 2]</li>
</ul>
<p>输出:</p>
<p>2</p>
<p><strong>解释:</strong></p>
<p>两个元组如下:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li>
</ol>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>定义一个哈希map，key放a和b俩数之和，value放a和b俩数和出现的次数</li>
<li>遍历A、B数组，统计两数和和出现次数</li>
<li>再遍历C、D数组、找到0-（c+d）在map中出现，count+value（value即出现的次数）</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums2){</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> i + j;</span><br><span class="line">                map.put(sum,map.getOrDefault(sum,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4){</span><br><span class="line">                r += map.getOrDefault(<span class="number">0</span> - i - j,<span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><code>getOrDefault</code> 核心作用：<strong>简化 Map 中 “获取值 + 处理键不存在” 的逻辑</strong>，避免手动判断 <code>containsKey</code>。
<ul>
<li>尝试从 <code>Map</code> 中获取指定 <code>key</code> 对应的 <code>value</code>；</li>
<li>如果 <code>key</code> <strong>存在</strong>，返回对应的 <code>value</code>；</li>
<li>如果 <code>key</code> <strong>不存在</strong>，返回你指定的 <code>defaultValue</code>（默认值）。</li>
</ul>
</li>
<li>语法规则：<code>map.getOrDefault(键, 默认值)</code>，返回值类型和 “默认值” 类型一致（比如键是 Integer，默认值也得是 Integer）。</li>
<li>典型场景：计数统计（如四数相加的次数统计）、避免空值（NPE）、默认值兜底等。</li>
<li>关键逻辑：利用 <code>a + b + c + d = 0</code> 等价于 <code>a + b = -(c + d)</code>，通过哈希表快速匹配目标值。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>用栈实现队列</title>
    <url>/2026/01/27/ImplementAQueueUsingStacks/</url>
    <content><![CDATA[<h1>算法-用栈实现队列</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–用栈实现队列</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>使用栈实现队列的下列操作：</p>
<p>push(x) – 将一个元素放入队列的尾部。<br>
pop() – 从队列首部移除元素。<br>
peek() – 返回队列首部的元素。<br>
empty() – 返回队列是否为空。</p>
<p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> <span class="built_in">MyQueue</span>();</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">peek</span>();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">empty</span>(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</li>
</ul>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>
<p><strong>核心矛盾</strong>：栈是「后进先出（LIFO）」，队列是「先进先出（FIFO）」，单个栈无法实现队列，需用<strong>两个栈（输入栈 + 输出栈）</strong> 配合；</p>
</li>
<li>
<p><strong>输入栈（stackIn）</strong>：专门处理 <code>push</code> 操作，所有新元素先压入输入栈；</p>
</li>
<li>
<p><strong>输出栈（stackOut）</strong>：专门处理 <code>pop/peek</code> 操作，当输出栈为空时，将输入栈的所有元素「倒序」压入输出栈（此时输出栈的栈顶就是队列的队首）；</p>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line">    <span class="comment">// 输入栈：仅用于push操作，存储待倒序的元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    <span class="comment">// 输出栈：仅用于pop/peek操作，存储已倒序的元素（栈顶=队首）</span></span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    <span class="comment">// 初始化两个栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> {</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 入队：直接压入输入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 出队：先倒腾元素到输出栈，再弹出输出栈栈顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 核心：输出栈为空时，才将输入栈元素倒压入输出栈</span></span><br><span class="line">        dumpstackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 查看队首：逻辑同pop，仅不弹出元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断队列是否为空：两个栈都为空时，队列才为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//将输入栈元素倒压入输出栈（仅当输出栈为空时执行）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpstackIn</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 输出栈非空时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!stackOut.isEmpty()){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 输入栈元素依次弹出，压入输出栈</span></span><br><span class="line">        <span class="keyword">while</span>(!stackIn.isEmpty()){</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>面试中需掌握「双栈→队列」和「双队列→栈」的双向转换思路，以及时间复杂度分析。</li>
<li>面试可能考点：
<ul>
<li>为什么需要两个栈？
<ul>
<li>核心原因：<strong>栈是「后进先出（LIFO）」，队列是「先进先出（FIFO）」，单个栈无法扭转元素的顺序</strong>。</li>
<li>简单说：<strong>一个栈负责「进」，一个栈负责「出」，两个栈配合完成「先进先出」的转换</strong>。</li>
</ul>
</li>
<li>倒腾元素的时机？（核心优化点）
<ul>
<li>倒腾时机：<strong>仅当输出栈为空时，才把输入栈的所有元素倒腾到输出栈</strong>（「懒加载」策略）。</li>
</ul>
</li>
<li>拓展问题：如何用队列实现栈？（反向思路）
<ul>
<li>栈是「后进先出」，队列是「先进先出」，核心思路：<strong>用两个队列，每次入队后倒腾 n-1 个元素，让「最后入队的元素」留在队列头（模拟栈顶）</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>用队列实现栈</title>
    <url>/2026/01/28/ImplementAStackUsingAQueue/</url>
    <content><![CDATA[<h1>算法-用队列实现栈</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–用队列实现栈</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<p>注意:</p>
<ul>
<li>你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）</li>
</ul>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><strong>核心矛盾</strong>：队列是「先进先出（FIFO）」，栈是「后进先出（LIFO）」，需通过「队列元素倒腾」让「最后入队的元素」留在队首（模拟栈顶）；</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">       queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();  <span class="comment">// 记录入队前的元素个数</span></span><br><span class="line">        queue.offer(x);</span><br><span class="line">         <span class="comment">// 把前面size个旧元素逐个出队，再入队到队尾，新元素留在队首（栈顶）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;size;i++){</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><strong>面试可能考点</strong>：
<ul>
<li>单队列 vs 双队列实现对比：
<ul>
<li>双队列：入队 O (1)，出队 O (n)（倒腾 n-1 个元素）；</li>
<li>单队列：入队 O (n)，出队 O (1)；</li>
<li>本质：都是「空间换时间」，总时间复杂度一致，单队列代码更简洁；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>实现strStr()</title>
    <url>/2026/01/27/ImplementstrStr()/</url>
    <content><![CDATA[<h1>算法-实现strStr()</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–实现strStr()</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p>
<p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p>
<p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><strong>strStr () 的本质是「字符串匹配」</strong>：在<code>haystack</code>（主串）中找<code>needle</code>（模式串）的第一个出现位置。</li>
<li><strong>前缀表（next 数组）</strong>：记录模式串<code>needle</code>中每个位置的「最长相等前后缀长度」，目的是当匹配失败时，模式串不用从头匹配，而是回退到最长相等前缀的位置，减少重复匹配。
<ul>
<li>前缀：不包含最后一个字符的所有以第一个字符开头的子串（比如<code>"abc"</code>的前缀是<code>"a"</code>、<code>"ab"</code>）；</li>
<li>后缀：不包含第一个字符的所有以最后一个字符结尾的子串（比如<code>"abc"</code>的后缀是<code>"c"</code>、<code>"bc"</code>）；</li>
</ul>
</li>
<li><strong>匹配过程</strong>：
<ul>
<li>用两个指针<code>i</code>（主串指针）、<code>j</code>（模式串指针）遍历；</li>
<li>当<code>haystack[i] == needle[j]</code>时，两个指针同时后移；</li>
<li>当匹配失败时，<code>j</code>根据 next 数组回退（<code>j = next[j-1]</code>），而<code>i</code>不回退；</li>
<li>当<code>j == needle.length()</code>时，说明匹配成功，返回起始位置<code>i - needle.length() + 1</code>。</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> {</span><br><span class="line">        <span class="comment">// 1. 处理边界：模式串为空，直接返回0（题目要求）</span></span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">         <span class="comment">// 2. 构建next数组（前缀表），长度等于模式串长度</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 模式串指针，初始为0</span></span><br><span class="line">         <span class="comment">// 3. 遍历主串（i是主串指针）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; haystack.length();i++){</span><br><span class="line">         <span class="comment">// 3.1 匹配失败：j回退（直到j=0或匹配成功）</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)){</span><br><span class="line">                j = next[j-<span class="number">1</span>];<span class="comment">// 核心：根据前缀表回退，避免暴力回退</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 3.2 匹配成功：j后移</span></span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(j) ==  haystack.charAt(i)){</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">             <span class="comment">// 3.3 完全匹配：返回起始位置</span></span><br><span class="line">            <span class="keyword">if</span>(j == needle.length()){</span><br><span class="line">                <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 构建next数组（前缀表）的核心方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next,String needle)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// j表示最长相等前后缀的长度，也指向前缀的末尾</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; needle.length(); i++){</span><br><span class="line">             <span class="comment">// 前后缀不相等时，j回退到上一个前缀表的位置，直到相等或j=0</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;needle.charAt(j) != needle.charAt(i)){</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">           <span class="comment">// 前后缀相等，j后移（最长相等前后缀长度+1）</span></span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(j) == needle.charAt(i)){</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">             <span class="comment">// 记录当前位置的前缀表值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>KMP 算法的核心价值
<ul>
<li>解决「字符串匹配」问题，避免暴力匹配的重复遍历，时间复杂度从 O (n*m) 优化到 O (n+m)；</li>
<li>前缀表（next 数组）是 KMP 的灵魂，作用是「记录模式串每个位置的最长相等前后缀长度，匹配失败时指导模式串指针回退」。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>KMP</tag>
        <tag>next数组</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2026/01/29/MaximumOfSlidingWindow/</url>
    <content><![CDATA[<h1>算法-滑动窗口最大值</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–滑动窗口最大值</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>进阶：</p>
<p>你能在线性时间复杂度内解决此题吗？</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><strong>核心逻辑：<strong>滑动窗口求最大值的核心是</strong>用「单调递减队列」维护窗口内的最大值候选</strong>： - 单调递减队列特性：队列中元素从队首到队尾依次递减，队首始终是当前窗口的最大值； - 核心优势：避免暴力遍历窗口（O(nk)），通过队列维护候选值，每个元素仅入队/出队一次，时间复杂度优化至O(n)。</li>
<li><strong>具体步骤：</strong>
<ul>
<li><strong>自定义单调队列</strong>（核心工具）：
<ul>
<li><code>poll(val)</code>：移除窗口左侧滑出的元素——仅当该元素是队首（当前最大值）时，才从队首弹出；</li>
<li><code>add(val)</code>：添加窗口右侧新元素——循环剔除队尾所有比当前val小的元素（这些元素不可能成为后续窗口的最大值），再将val加入队尾，保证队列单调递减；</li>
<li><code>peek()</code>：获取当前窗口的最大值（队首元素）。</li>
</ul>
</li>
<li><strong>滑动窗口执行流程</strong>：
<ul>
<li>初始化：将前k个元素加入单调队列，记录第一个窗口的最大值；</li>
<li>滑动遍历：从第k个元素开始，依次执行「移除窗口左侧元素→添加窗口右侧元素→记录当前窗口最大值」；</li>
<li>最终返回所有窗口的最大值数组。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 结果数组长度 = 窗口数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">          <span class="comment">// 第一步：初始化前k个元素到队列中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k; i++){</span><br><span class="line">            myQueue.add(nums[i]);</span><br><span class="line">        }</span><br><span class="line">         <span class="comment">// 记录第一个窗口的最大值</span></span><br><span class="line">          res[num++] = myQueue.peek();</span><br><span class="line">           <span class="comment">// 第二步：滑动窗口遍历（从第k个元素开始）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;i &lt; nums.length;i++){</span><br><span class="line">                <span class="comment">// 1. 移除窗口左侧滑出的元素（nums[i-k]是当前窗口要删掉的最左元素）</span></span><br><span class="line">            myQueue.poll(nums[i-k]);</span><br><span class="line">              <span class="comment">// 2. 添加窗口右侧新进入的元素（nums[i]是当前窗口要加的最右元素）</span></span><br><span class="line">            myQueue.add(nums[i]);</span><br><span class="line">             <span class="comment">// 3. 记录当前窗口的最大值</span></span><br><span class="line">            res[num++] = myQueue.peek();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>{</span><br><span class="line">     <span class="comment">// 底层用LinkedList实现双端队列，存储的是数组的值（而非下标）</span></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 方法1：弹出窗口左侧移除的元素（仅当该元素是队列的队首时才弹出）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span>{</span><br><span class="line">        <span class="comment">// 只有当队列非空，且要移除的val正好是队首（当前最大值）时，才弹出队首</span></span><br><span class="line">        <span class="comment">// 若val不是队首，说明它早已被add方法剔除，无需处理</span></span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty()&amp;&amp;val == deque.peek()){</span><br><span class="line">            deque.poll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">       <span class="comment">// 方法2：添加新元素到队列，维护单调递减性</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>{</span><br><span class="line">        <span class="comment">// 循环剔除队尾所有比当前val小的元素</span></span><br><span class="line">        <span class="comment">// 因为这些元素在val的右侧，不可能成为后续窗口的最大值</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()&amp;&amp;val&gt;deque.getLast()){</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        }</span><br><span class="line">            <span class="comment">// 此时队尾元素 &gt;= val，加入后队列仍保持单调递减</span></span><br><span class="line">        deque.add(val);</span><br><span class="line">    }</span><br><span class="line">     <span class="comment">// 方法3：获取当前队列的最大值（即队首元素）</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><strong>核心知识点:</strong>
<ul>
<li>单调队列的核心价值：滑动窗口问题中，通过「维护候选值的单调性」避免重复计算，将时间复杂度从暴力法的 O (nk) 优化至 O (n)；</li>
<li>单调递减队列的设计逻辑：
<ul>
<li>队首：当前窗口的最大值；</li>
<li>队中元素：后续窗口可能成为最大值的候选（按递减顺序排列）；</li>
<li>剔除规则：新元素加入时，剔除所有比它小的队尾元素（这些元素无成为最大值的可能）</li>
</ul>
</li>
<li>边界处理：数组长度为 1 时直接返回原数组，避免数组越界。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>赎金信</title>
    <url>/2026/01/21/RansomNote/</url>
    <content><![CDATA[<h1>算法-赎金信</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–赎金信</p>
</li>
<li>
<p>博主以[代码随想录](<a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html#%E6%80%9D%E8%B7%AF">383. 赎金信 | 代码随想录</a>)算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p><strong>注意：</strong></p>
<p>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>
canConstruct(“aa”, “ab”) -&gt; false<br>
canConstruct(“aa”, “aab”) -&gt; true</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>暴力枚举：俩层for循环</li>
<li>哈希数组：使用哈希数组，先定义一个哈希数组int[26]，遍历magazine字符串，在对应的下标增1，再遍历ransomNote字符串，在对应的数组下标减1，如果出现负数，表示false</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> {</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length()){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray()){</span><br><span class="line">            record[c - <span class="string">'a'</span>] += <span class="number">1</span>; <span class="comment">//即对应的下标加一</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray()){</span><br><span class="line">            record[c - <span class="string">'a'</span>] -= <span class="number">1</span>;  <span class="comment">//即对应的下标减一</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : record){</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>
<p>核心思路：<strong>用数组代替哈希表统计字符频次</strong>（仅小写字母场景），先统计 <code>magazine</code> 的字符数，再扣除 <code>ransomNote</code> 所需字符数，最后检查是否有字符不足。</p>
</li>
<li>
<p>关键转换：<code>c - 'a'</code> 将字符映射到数组下标，是处理小写字母计数的经典技巧。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希数组</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>重复的子字符串</title>
    <url>/2026/01/27/RepeatedSubstring/</url>
    <content><![CDATA[<h1>算法-重复的子字符串</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–重复的子字符串</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:</p>
<ul>
<li>输入: “abab”</li>
<li>输出: True</li>
<li>解释: 可由子字符串 “ab” 重复两次构成。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: “aba”</li>
<li>输出: False</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: “abcabcabcabc”</li>
<li>输出: True</li>
<li>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</li>
</ul>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>
<p>判断字符串<code>s</code>是否由某个子串重复多次构成，核心逻辑基于 KMP 的「最长相等前后缀」：</p>
</li>
<li>
<p>设字符串长度为<code>len</code>，其前缀表（next 数组）的最后一个值为<code>next[len-1]</code>。</p>
<p>如果满足两个条件：</p>
<ul>
<li><code>len % (len - next[len-1]) == 0</code>（字符串长度能被「长度 - 最长相等前后缀长度」整除）；</li>
<li><code>next[len-1] != 0</code>（存在非空的最长相等前后缀）。则字符串<code>s</code>可以由子串<code>s[0 : len - next[len-1]]</code>重复构成。</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++){</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;s.charAt(j) != s.charAt(i)){</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j) == s.charAt(i)){</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">         <span class="comment">// 3. 核心判断：是否由重复子串构成</span></span><br><span class="line">        <span class="comment">// 条件1：next[n-1] &gt; 0 → 存在非空的最长相等前后缀</span></span><br><span class="line">        <span class="comment">// 条件2：n % (n - next[n-1]) == 0 → 总长度能被「非前后缀部分的长度」整除</span></span><br><span class="line">        <span class="keyword">if</span>(next[n - <span class="number">1</span>]&gt;<span class="number">0</span>&amp;&amp;n%(n-next[n-<span class="number">1</span>])==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>next 数组的核心作用：记录模式串每个位置的最长相等前后缀长度，避免暴力匹配的重复遍历；</li>
<li>关键公式：最小重复子串长度 = 字符串总长度 - 最长相等前后缀长度，若总长度能被该值整除，则存在重复子串</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>KMP</tag>
        <tag>next数组</tag>
      </tags>
  </entry>
  <entry>
    <title>删除字符串中的所有相邻重复项</title>
    <url>/2026/01/29/RemoveAllAdjacentDuplicatesInAString/</url>
    <content><![CDATA[<h1>算法-删除字符串中的所有相邻重复项</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–删除字符串中的所有相邻重复项</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<ul>
<li>输入：“abbaca”</li>
<li>输出：“ca”</li>
<li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S 仅由小写英文字母组成</li>
</ul>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><strong>核心逻辑：<strong>利用</strong>栈的「后进先出」特性</strong>处理相邻重复项——遍历字符串时，用栈存储未重复的字符，当前字符与栈顶相同则弹出栈顶（删除重复项），不同则压入栈；</li>
<li><strong>具体步骤：</strong>
<ul>
<li>初始化栈，遍历字符串每个字符：
<ul>
<li>若栈为空 或 当前字符 ≠ 栈顶字符 → 压入栈（无重复，保留字符）；</li>
<li>若当前字符 = 栈顶字符 → 弹出栈顶（删除相邻重复项）；</li>
</ul>
</li>
<li>遍历结束后，栈中剩余字符即为「无相邻重复的最终字符串」，按顺序拼接即可。</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="comment">// 用ArrayDeque模拟栈（效率高于Stack）</span></span><br><span class="line">        ArrayDeque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">         <span class="comment">// 遍历字符串每个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">             <span class="comment">// 栈空 或 当前字符≠栈顶 → 压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(deque.isEmpty()||deque.peek() != ch){</span><br><span class="line">                deque.push(ch);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">// 当前字符=栈顶 → 弹出栈顶（删除重复项）</span></span><br><span class="line">                deque.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">         <span class="comment">// 拼接栈中剩余字符（栈是倒序，需从栈底到栈顶拼接）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()){</span><br><span class="line">            <span class="comment">// 每次取栈顶拼接到字符串前面，保证顺序正确</span></span><br><span class="line">            str = deque.pop() + str;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><strong>栈的经典应用</strong>：相邻重复项的删除符合「后进先出」逻辑 —— 最新遍历的字符需与「最近未重复的字符（栈顶）」匹配，栈天然适配这种场景；</li>
<li><strong>效率优势</strong>：相比「暴力遍历 + 反复删除」（时间复杂度 O (n²)），栈解法仅需一次遍历（O (n)），是最优解；</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>替换数字</title>
    <url>/2026/01/25/ReplaceNumbers/</url>
    <content><![CDATA[<h1>算法-替换数字</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–替换数字</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p>
<p>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p>
<p>对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”</p>
<p>输入：一个字符串 s,s 仅包含小写字母和数字字符。</p>
<p>输出：打印一个新的字符串，其中每个数字字符都被替换为了number</p>
<p>样例输入：a1b2c3</p>
<p>样例输出：anumberbnumbercnumber</p>
<p>数据范围：1 &lt;= s.length &lt; 10000。</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><strong>统计数字数量</strong>：
<ul>
<li>先遍历原字符串，统计其中数字字符的个数。这一步的核心目的是计算新字符串的长度 —— 因为每个数字（1 个字符）要替换成 “number”（6 个字符），相当于每个数字会让字符串长度增加 5，因此新长度 = 原长度 + 数字个数 × 5。</li>
</ul>
</li>
<li><strong>创建新字符数组</strong>：
<ul>
<li>基于计算出的新长度，创建一个固定长度的字符数组</li>
</ul>
</li>
<li><strong>双指针从后往前填充：</strong>
<ul>
<li>定义两个指针：<code>i</code>指向新字符数组的末尾（待填充位置），<code>j</code>指向原字符串的末尾（待遍历位置）。</li>
<li>从后往前遍历原字符串：
<ul>
<li>如果<code>j</code>指向的是字母，直接将该字母复制到<code>i</code>的位置，然后<code>i</code>和<code>j</code>都向前移动一位；</li>
<li>如果<code>j</code>指向的是数字，从<code>i</code>的位置向前依次填充 ‘r’、‘e’、‘b’、‘m’、‘u’、‘n’（即 “number” 的逆序），然后<code>i</code>向前移动 6 位，<code>j</code>向前移动一位。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceNumber</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sOldSize</span> <span class="operator">=</span> s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一步：统计字符串中的数字数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sOldSize; i++) {</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) {</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二步：创建新字符数组，长度 = 原长度 + 数字个数*5（number是6个字符，替换1个数字多占5位）</span></span><br><span class="line">        <span class="type">char</span>[] newS = <span class="keyword">new</span> <span class="title class_">char</span>[sOldSize + count * <span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sNewSize</span> <span class="operator">=</span> newS.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第三步：双指针从后往前填充（核心修正）</span></span><br><span class="line">        <span class="comment">// i：新数组指针，j：原字符串指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">            <span class="comment">// 如果是字母，直接复制到新数组</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(s.charAt(j))) {</span><br><span class="line">                newS[i] = s.charAt(j);</span><br><span class="line">                i--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 如果是数字，替换为"number"（从后往前填）</span></span><br><span class="line">                newS[i] = <span class="string">'r'</span>;</span><br><span class="line">                newS[i - <span class="number">1</span>] = <span class="string">'e'</span>;</span><br><span class="line">                newS[i - <span class="number">2</span>] = <span class="string">'b'</span>;</span><br><span class="line">                newS[i - <span class="number">3</span>] = <span class="string">'m'</span>;</span><br><span class="line">                newS[i - <span class="number">4</span>] = <span class="string">'u'</span>;</span><br><span class="line">                newS[i - <span class="number">5</span>] = <span class="string">'n'</span>;</span><br><span class="line">                i -= <span class="number">6</span>; <span class="comment">// 直接移动6位，避免循环的i--干扰（更清晰）</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newS);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(replaceNumber(s));</span><br><span class="line">        scanner.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>从后往前填充的优势：避免从前往后填充时数字替换导致的字符覆盖，无需频繁移动已处理的字符，时间复杂度为 O (n)（n 为原字符串长度）。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串</title>
    <url>/2026/01/24/ReverseAString/</url>
    <content><![CDATA[<h1>算法-反转字符串</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–反转字符串</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：<br>
输入：[“h”,“e”,“l”,“l”,“o”]<br>
输出：[“o”,“l”,“l”,“e”,“h”]</p>
<p>示例 2：<br>
输入：[“H”,“a”,“n”,“n”,“a”,“h”]<br>
输出：[“h”,“a”,“n”,“n”,“a”,“H”]</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>采用双指针法</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> {</span><br><span class="line">        <span class="comment">// 左指针：初始指向数组头部</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右指针：初始指向数组尾部</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 两指针未相遇时循环交换</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">            <span class="comment">// 临时变量存储左指针值，避免覆盖</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> s[l];</span><br><span class="line">            <span class="comment">// 交换左右指针对应的值</span></span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = t;</span><br><span class="line">            <span class="comment">// 左指针右移</span></span><br><span class="line">            l++;</span><br><span class="line">            <span class="comment">// 右指针左移</span></span><br><span class="line">            r--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>还可以使用位运算</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串Ⅱ</title>
    <url>/2026/01/24/ReverseAString%E2%85%A1/</url>
    <content><![CDATA[<h1>算法-反转字符串Ⅱ</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–反转字符串Ⅱ</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s = “abcdefg”, k = 2<br>
输出: “bacdfeg”</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>分段遍历 + 双指针反转</li>
<li><strong>分段逻辑</strong>：将字符串按 2k 长度分段，遍历步长设为 2k（<code>i += 2*k</code>）；</li>
<li><strong>边界处理</strong>：对每一段，计算反转的结束指针 end：
<ul>
<li>若剩余字符 ≥k → end = start + k - 1；</li>
<li>若剩余字符 &lt;k → end = 数组最后一个索引（用 <code>Math.min</code> 统一处理）；</li>
</ul>
</li>
<li><strong>复用基础反转</strong>：在 [start, end] 区间内，用“双指针+临时变量交换”反转字符；</li>
<li><strong>类型转换</strong>：String 不可变，先转为 char[] 原地修改，最后转回 String。</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 代码</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="comment">// 转为字符数组，支持原地修改</span></span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">// 按2k步长分段遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k){</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 关键：处理剩余字符不足k的边界情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 双指针反转[start, end]区间字符</span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end){</span><br><span class="line">                <span class="comment">// 临时变量交换（新手友好，易理解）</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">                ch[start] = ch[end];</span><br><span class="line">                ch[end] = temp;</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 字符数组转回字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><strong>核心难点</strong>：end指针的边界计算（<code>Math.min</code> 的使用），解决“剩余字符不足k”的越界问题；</li>
<li><code>Math.min(a, b)</code>取 a 和 b 中的<strong>较小值</strong></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的单词</title>
    <url>/2026/01/26/ReverseTheWordsInAString/</url>
    <content><![CDATA[<h1>反转字符串中的单词</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构–反转字符串中的单词</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="问题">问题</h2>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：<br>
输入: “the sky is blue”<br>
输出: “blue is sky the”</p>
<p>示例 2：<br>
输入: "  hello world!  "<br>
输出: “world! hello”<br>
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：<br>
输入: “a good  example”<br>
输出: “example good a”<br>
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个</p>
<h2 id="思路">思路</h2>
<ul>
<li><strong>清理多余空格</strong>：去除字符串首尾的空格，同时将单词之间的多个空格缩减为一个。</li>
<li><strong>反转整个字符串</strong>：将清理后的字符串整体反转。</li>
<li><strong>反转每个单词</strong>：遍历反转后的字符串，将每个独立的单词再反转回来，最终得到单词顺序反转的结果。</li>
<li><strong>快慢指针法</strong>：
<ul>
<li><strong>快指针（fast）</strong>：负责遍历原始字符数组，寻找有效字符（非空格）。</li>
<li><strong>慢指针（slow）</strong>：负责在原数组上 “构建” 无多余空格的新数组，记录有效字符的存放位置。</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> {</span><br><span class="line">         <span class="comment">// 1. 去除多余空格（首尾空格 + 单词间多余空格）</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        chars = reverseExtraSpaces(chars);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 反转整个字符串</span></span><br><span class="line">        reverse(chars,<span class="number">0</span>,chars.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 反转每个单词</span></span><br><span class="line">        reverseEachWord(chars);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去掉多余空格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] reverseExtraSpaces(<span class="type">char</span>[] chars){</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 慢指针：记录有效字符的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;fast&lt;chars.length;fast++){</span><br><span class="line">             <span class="comment">// 只处理非空格字符（跳过所有空格）</span></span><br><span class="line">            <span class="keyword">if</span>(chars[fast] != <span class="string">' '</span>){ </span><br><span class="line">             <span class="comment">// 如果不是第一个单词，先在单词前加一个空格（避免开头有空格）   </span></span><br><span class="line">                <span class="keyword">if</span>(slow != <span class="number">0</span>){</span><br><span class="line">                    chars[slow++] = <span class="string">' '</span>; </span><br><span class="line">                    }</span><br><span class="line">                 <span class="comment">// 把当前单词的所有字符复制到慢指针位置</span></span><br><span class="line">                 <span class="comment">// 循环条件：fast没越界 且 当前字符不是空格（即还在同一个单词内）</span></span><br><span class="line">                    <span class="keyword">while</span>(fast &lt; chars.length &amp;&amp; chars[fast] != <span class="string">' '</span>)</span><br><span class="line">                       chars[slow++] = chars[fast++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 截取有效长度的字符数组（去掉后面的无效部分）</span></span><br><span class="line">        <span class="type">char</span>[] newChars = <span class="keyword">new</span> <span class="title class_">char</span>[slow];</span><br><span class="line">        System.arraycopy(chars,<span class="number">0</span>,newChars,<span class="number">0</span>,slow);</span><br><span class="line">        <span class="keyword">return</span> newChars;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//反转指定区间的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> left, <span class="type">int</span> right)</span>{</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=chars.length){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">         <span class="comment">// 双指针交换左右字符，向中间靠拢</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//反转每个单词</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(<span class="type">char</span>[] chars)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录每个单词的起始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;end &lt;=chars.length;end++){</span><br><span class="line">            <span class="keyword">if</span>(end == chars.length || chars[end] == <span class="string">' '</span>){</span><br><span class="line">                reverse(chars,start,end-<span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;<span class="comment">// 更新下一个单词的起始位置</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>记住三步走：清理空格、反转整体、反转单词（区间）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>右旋转字符串</title>
    <url>/2026/01/26/Right-RotateString/</url>
    <content><![CDATA[<h1>右旋转字符串</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构–右旋转字符串</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="问题">问题</h2>
<p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p>
<p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p>
<p>输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p>
<p>输出：输出共一行，为进行了右旋转操作后的字符串。</p>
<p>样例输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">abcdefg </span><br></pre></td></tr></table></figure>
<p>样例输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fgabcde</span><br></pre></td></tr></table></figure>
<p>数据范围：1 &lt;= k &lt; 10000, 1 &lt;= s.length &lt; 10000;</p>
<h2 id="思路">思路</h2>
<ul>
<li><strong>三次反转</strong>
<ul>
<li><strong>反转整个字符串</strong>：把原字符串整体反转，让尾部的 <code>k</code> 个字符到开头，开头的 <code>len-k</code> 个字符到结尾。</li>
<li><strong>反转前 k 个字符</strong>：将第一步中移到开头的 <code>k</code> 个字符（原尾部）反转回原本的顺序。</li>
<li><strong>反转剩余 len-k 个字符</strong>：将第一步中移到结尾的 <code>len-k</code> 个字符（原开头）反转回原本的顺序。</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 1. 读取输入的右旋转位数 k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(in.nextLine().trim());<span class="comment">// 加trim避免输入空格干扰</span></span><br><span class="line">        <span class="comment">// 2. 读取需要旋转的字符串 s</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 将字符串转为字符数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">// 4. 三次反转核心逻辑</span></span><br><span class="line">        reverseString(chars,<span class="number">0</span>,len-<span class="number">1</span>);<span class="comment">// 反转整个字符串</span></span><br><span class="line">        reverseString(chars,<span class="number">0</span>,n-<span class="number">1</span>);    <span class="comment">//反转前k个字符串</span></span><br><span class="line">        reverseString(chars,n,len-<span class="number">1</span>);<span class="comment">// 反转剩余字符</span></span><br><span class="line">        System.out.println(chars);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> start,<span class="type">int</span> end)</span>{</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end){</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">            ch[start] = ch[end];</span><br><span class="line">            ch[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>三次反转</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>栈模拟计算器</title>
    <url>/2024/11/05/StackSimulatorCalculator/</url>
    <content><![CDATA[<h1>栈模拟计算器</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——栈</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>
<p>定义两个栈，一个为数栈numStack，用于存放数，一个为符号栈operStack，用于存放运算符</p>
</li>
<li>
<p>设置索引index遍历表达式</p>
</li>
<li>
<p>index指数，则直接入数栈</p>
</li>
<li>
<p>index扫描为运算符，则分不同情况</p>
<ul>
<li>符号栈为空，直接入栈</li>
<li>符号栈不为空，就进行比较
<ul>
<li>当前运算符的优先级小于或等于栈中的运算符，就从数栈中取出两个数和从符号栈中取出一个符号进行运算，将结果入数栈，再将当前的运算符入符号栈</li>
<li>当前运算符的优先级大于栈中的运算符，直接入符号栈</li>
</ul>
</li>
</ul>
</li>
<li>
<p>当整个表达式扫描完毕，就可以按顺序pop出数字和符号进行运算了</p>
</li>
<li>
<p>数栈的最后一个数就是结果</p>
</li>
</ul>
<h2 id="实现步骤">实现步骤</h2>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="meta">@SuppressWarnings({""})</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">"8-2*3+1"</span>;</span><br><span class="line">        <span class="comment">//创建两个栈，一个数栈，一个符号栈</span></span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义相关变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">' '</span>;<span class="comment">//将每次扫描得到char保存到ch</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">" "</span>;<span class="comment">//变量，用于拼接多位数</span></span><br><span class="line">        <span class="comment">//开始while扫描expression</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//依次得到expression的每一个字符</span></span><br><span class="line">            ch = expression.substring(index,index+<span class="number">1</span>).charAt(<span class="number">0</span>);<span class="comment">//substring用法</span></span><br><span class="line">            <span class="comment">//判断ch是什么做相应处理</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isOper(ch)){<span class="comment">//如果是运算符</span></span><br><span class="line">                <span class="comment">//判断当前符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty()){</span><br><span class="line">                    <span class="comment">//如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就需要重数栈中取出两数</span></span><br><span class="line">                    <span class="comment">//从符号栈中取出一个符号进行运算，将运算结果入数栈，将当前操作符入符号栈</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch)&lt;= operStack.priority(operStack.peek())){</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1,num2,oper);</span><br><span class="line">                        <span class="comment">//把运算结果入数栈</span></span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//把当前符号入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        <span class="comment">//如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    }</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="comment">//如果为空直接入栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//如果是数直接入数栈</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">//            numStack.push(ch-48);//在表中‘1’是49</span></span><br><span class="line">                <span class="comment">//思路分析</span></span><br><span class="line">                <span class="comment">//1.当处理多位数时，不能发现一个数就入栈</span></span><br><span class="line">                <span class="comment">//2.在处理数时，需要向expression的表达式的index后看一位，如果是数就进行扫描，是符号就入栈</span></span><br><span class="line">                <span class="comment">//3.需要 定义一个变量字符串用于拼接</span></span><br><span class="line">                <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line">                <span class="comment">//如果ch已经是最后一位就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span> (index == expression.length()-<span class="number">1</span>){</span><br><span class="line">                      numStack.push(Integer.parseInt(keepNum.trim()));</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="comment">//判断下个字符是是不是数字，如果是数字就继续扫描，是符号就入栈</span></span><br><span class="line">                    <span class="comment">//注意是看后一位，不是index++</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>))){</span><br><span class="line">                        <span class="comment">//是的话，后面一位是符号，入栈</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum.trim()));</span><br><span class="line">                        <span class="comment">//重要：keepNum清空</span></span><br><span class="line">                        keepNum = <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//让index+1，判断是否扫描到expression最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index&gt;= expression.length()){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">           <span class="comment">// 当表达式扫描完毕，就顺序从数栈和符号栈pop出数进行运算</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算到最后结果</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isEmpty()){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1,num2,oper);</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(expression+<span class="string">"="</span>+numStack.pop());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//先创建一个栈，需要扩展功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack2</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//数组模拟栈，数据放在该数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack2</span><span class="params">(<span class="type">int</span> maxSize)</span> {</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//增加一个方法，可以返回当前栈顶的值,但不是取出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> top == maxSize -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//入栈push</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>{</span><br><span class="line">        <span class="comment">//判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull()){</span><br><span class="line">            System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//出栈pop，将栈顶数据返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">//先判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()){</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"栈空"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//遍历栈，遍历时要从栈顶开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()){</span><br><span class="line">            System.out.println(<span class="string">"栈空没有数据"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//从栈顶开始显示数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            System.out.printf(<span class="string">"stack[%d]==%d\n"</span>,i,stack[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//返回运算符优先级，由程序员确定，用数字表示，数字越大，优先级越高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span>{</span><br><span class="line">        <span class="keyword">if</span> (oper==<span class="string">'*'</span>||oper==<span class="string">'/'</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(oper==<span class="string">'+'</span>||oper==<span class="string">'-'</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假定只有加减乘除</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span>{</span><br><span class="line">        <span class="keyword">return</span> val ==<span class="string">'+'</span>||val==<span class="string">'-'</span>||val==<span class="string">'*'</span>||val==<span class="string">'/'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//res用于存放结果</span></span><br><span class="line">        <span class="keyword">switch</span>(oper){</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                res = num2 - num1;<span class="comment">//注意顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                res = num2 / num1;<span class="comment">//注意顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2026/01/22/SumOfThreeNumbers/</url>
    <content><![CDATA[<h1>算法-三数之和</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–三数之和</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>哈希法：俩层for循环，再用哈希法确定第3个数，但是去重难度大</li>
<li>双指针法：先将数组排序，一层for循环，i重下标为0开始，建立left指针指向i的下一位、rigth指针指向最后一位</li>
<li>nums[i] + nums[left] + nums[right] &gt; 0表示大了，right向左移</li>
<li>nums[i] + nums[left] + nums[right] &lt; 0表示小了，left向右移</li>
<li>nums[i] + nums[left] + nums[right] = 0表示找到符合标准的</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//排序，为去重准备</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> result; <span class="comment">//首位最小但是大于0，表示没有负数，直接返回结果</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]){    <span class="comment">//去重，</span></span><br><span class="line">                <span class="keyword">continue</span>;             </span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;   <span class="comment">//左指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rigth</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;  <span class="comment">//右指针</span></span><br><span class="line">            <span class="keyword">while</span>(rigth &gt; left){       <span class="comment">//没有=，因为要求3位数，等于只剩2位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] +nums[rigth];  </span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>){   <span class="comment">//和大，右指针往左移动</span></span><br><span class="line">                    rigth--;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>){ <span class="comment">//和小，左指针往右移动</span></span><br><span class="line">                    left++;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[left],nums[rigth]));  <span class="comment">//找到符合的结果</span></span><br><span class="line">                    <span class="keyword">while</span>(rigth &gt; left &amp;&amp; nums[rigth] == nums[rigth-<span class="number">1</span>]){    <span class="comment">//去重</span></span><br><span class="line">                        rigth--;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">while</span>(rigth &gt; left &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]){   <span class="comment">//去重</span></span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    rigth--;</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>三数之和的核心逻辑是：排序 + 固定第一个数 + 双指针找后两个数，去重逻辑是避免重复三元组的关键。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>四数之和</title>
    <url>/2026/01/23/SumOfFourNumbers/</url>
    <content><![CDATA[<h1>算法-四数之和</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–四数之和</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>这道题是经典的「N 数之和」问题，核心思路是<strong>排序 + 双指针</strong>，通过降维将四数之和转化为三数之和，再转化为两数之和，同时通过剪枝和去重避免重复结果：
<ul>
<li>排序：对数组排序</li>
<li>俩层循环固定前俩个数</li>
<li>双指针找后俩个数</li>
<li>剪枝优化</li>
<li>去重</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="comment">// 结果集初始化</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 边界条件：数组长度小于4，直接返回空结果</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 排序数组（核心前提）</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 第一层循环：固定第一个数 nums[k]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length - <span class="number">3</span>; k++) {</span><br><span class="line">            <span class="comment">// 剪枝1：如果当前数大于target且非负，后续数更大，不可能凑出target，直接终止循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 去重1：跳过和前一个数重复的nums[k]（避免重复四元组）</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 第二层循环：固定第二个数 nums[i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt; nums.length - <span class="number">2</span>; i++) {</span><br><span class="line">                <span class="comment">// 剪枝2：前两个数的和大于target且非负，后续数更大，终止内层循环</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 去重2：跳过和前一个数重复的nums[i]（注意i的起始是k+1，所以去重条件是i &gt; k+1）</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4. 双指针：找后两个数 nums[left] 和 nums[right]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) {</span><br><span class="line">                    <span class="comment">// 用long避免int溢出（关键！比如大数相加会超出int范围）</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right];</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">                        <span class="comment">// 和太大，右指针左移（减小和）</span></span><br><span class="line">                        right--;</span><br><span class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                        <span class="comment">// 和太小，左指针右移（增大和）</span></span><br><span class="line">                        left++;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// 5. 找到符合条件的四元组，加入结果集</span></span><br><span class="line">                        result.add(Arrays.asList(nums[k], nums[i], nums[left], nums[right]));</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 去重3：跳过重复的nums[right]</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) {</span><br><span class="line">                            right--;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 去重4：跳过重复的nums[left]</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) {</span><br><span class="line">                            left++;</span><br><span class="line">                        }</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 6. 双指针同时移动，找下一组可能的数</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>N 数之和问题均可通过「排序 + 双指针」降维解决（三数之和是一层循环 + 双指针，四数之和是两层循环 + 双指针）。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>单向环形链表</title>
    <url>/2024/09/17/Unidirectionalcircularlinkedlist/</url>
    <content><![CDATA[<h1>单向环形链表</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——单向链表</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="问题">问题</h2>
<p>Josephu（约瑟夫，约瑟夫环）问题</p>
<p>设编号1，2，3…n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，它 的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人出列为止。</p>
<h2 id="思路">思路</h2>
<ul>
<li>
<p>构建一个单向环形链表的思路</p>
<ul>
<li>先创建第一个节点，让first指向该节点,并形成环形</li>
<li>后面当我们每创建一个新的节点，就把该节点加入到已有的环形链表当中</li>
</ul>
</li>
<li>
<p>遍历环形链表</p>
<ul>
<li>先让一个辅助指针（变量）<strong>curboy</strong>，指向<strong>first</strong>节点</li>
<li>然后通过一个while循环遍历该环形链表</li>
<li><strong>curBoy.next == firs</strong>t遍历结束</li>
</ul>
</li>
<li>
<p>出圈</p>
<ul>
<li>
<p>先创建一个辅助指针<strong>helper</strong>，先指向环形链表的最后节点</p>
</li>
<li>
<p>小孩报数前，先让<strong>first</strong>和<strong>helper</strong>移动k-1次</p>
</li>
<li></li>
<li>
<p>这时就可以将<strong>first</strong>指向的小孩节点出圈</p>
<ul>
<li>
<p><strong>first = first.next</strong></p>
</li>
<li>
<p><strong>helper.next= first</strong></p>
</li>
<li>
<p>原来的节点没有被引用，就会被回收</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li>
<p>创建一个Boy类，表示一个节点</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>{</span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//表示指向下个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span>{</span><br><span class="line">        <span class="built_in">this</span>.no=no;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> {</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> {</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>创建一个单向环形链表CircleSingleLinkedList类</p>
<ul>
<li>
<p>创建一个first节点，当前没有编号</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span>{</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(-<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>添加小孩节点addBoy，构建一个环形链表</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span>{</span><br><span class="line">    <span class="comment">//nums做一个数据校验</span></span><br><span class="line">    <span class="keyword">if</span>(nums&lt;<span class="number">1</span>){</span><br><span class="line">        System.out.println(<span class="string">"nums不正确"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//辅助变量，帮助构建环形链表</span></span><br><span class="line">    <span class="comment">//使用for来创建我们的环形链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=nums;i++){</span><br><span class="line">        <span class="comment">//根据编号，创建小孩节点</span></span><br><span class="line">       <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">       <span class="comment">//如果是第一个小孩</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>){</span><br><span class="line">            first =boy;</span><br><span class="line">            first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">            curBoy = first;<span class="comment">//让curBoy指向第一个小孩</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">              curBoy.setNext(boy);</span><br><span class="line">              boy.setNext(first);</span><br><span class="line">              curBoy = boy;</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>遍历当前环形链表</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"没有任何小孩"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="comment">//因为first不能动，所以使用辅助指针</span></span><br><span class="line">    <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            System.out.printf(<span class="string">"小孩的编号%d\n"</span>,curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span>(curBoy.getNext()==first){<span class="comment">//说明遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            curBoy = curBoy.getNext();<span class="comment">//curBoy后移</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>根据用户输入，计算小孩出圈的顺序</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据用户输入，计算小孩出圈的顺序</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo,<span class="type">int</span> countNum,<span class="type">int</span> nums)</span>{</span><br><span class="line">     <span class="comment">//startNo表示从哪个小孩开始数</span></span><br><span class="line">     <span class="comment">//countNum表示数几下</span></span><br><span class="line">     <span class="comment">//nums表示最初有多少小孩在圈中</span></span><br><span class="line">     <span class="keyword">if</span>(first==<span class="literal">null</span>||startNo&lt;<span class="number">1</span>||startNo&gt;nums){</span><br><span class="line">         System.out.println(<span class="string">"参数输入有误，请重新输入"</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//创建辅助指针，帮助小孩出圈</span></span><br><span class="line">     <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">     <span class="comment">//应指向环形链表最后节点</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">         <span class="keyword">if</span>(helper.getNext() == first){</span><br><span class="line">             <span class="comment">//说明helper指向最后小孩节点</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         }</span><br><span class="line">         helper = helper.getNext();</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//小孩报数前，先让first和helper移动k-1次</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j= <span class="number">0</span>;j&lt;startNo-<span class="number">1</span>;j++){</span><br><span class="line">         first = first.getNext();</span><br><span class="line">         helper = helper.getNext();</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//当小孩报数时，让first和helper指针同时移动m-1次,直到圈中只有一个人</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">         <span class="keyword">if</span>(helper == first){<span class="comment">//说明圈中只有一个人</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//让first和helper指针同时移动countNum-1，然后出圈</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">0</span>;j&lt;countNum-<span class="number">1</span>;j++){</span><br><span class="line">             first = first.getNext();</span><br><span class="line">             helper = helper.getNext();</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//这时first指向的节点就是小孩出圈的节点</span></span><br><span class="line">         System.out.printf(<span class="string">"小孩%d出圈\n"</span>,first.getNo());</span><br><span class="line">         <span class="comment">//这时将first指向小孩节点出圈</span></span><br><span class="line">         first = first.getNext();</span><br><span class="line">         helper.setNext(first);</span><br><span class="line">     }</span><br><span class="line">     System.out.printf(<span class="string">"最后留在圈中的小孩编号%d\n"</span>,first.getNo());</span><br><span class="line"> }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>前 K 个高频元素</title>
    <url>/2026/01/30/TopKFrequentElements/</url>
    <content><![CDATA[<h1>算法-前 K 个高频元素</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–前 K 个高频元素</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<ul>
<li>输入: nums = [1,1,1,2,2,3], k = 2</li>
<li>输出: [1,2]</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: nums = [1], k = 1</li>
<li>输出: [1]</li>
</ul>
<p>提示：</p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度必须优于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.847ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4352.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1918.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"/><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"/></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="2061" d=""/></g><g data-mml-node="mi" transform="translate(3363.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3963.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> , n 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案</li>
</ul>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>**核心逻辑：**前K个高频元素的核心解法是「<strong>哈希表统计频率 + 小顶堆筛选高频元素</strong>」：
<ul>
<li>哈希表：统计每个元素的出现频率（O(n)）；</li>
<li>小顶堆：维护当前「频率前k高」的元素，堆顶是这k个元素中频率最低的，遍历过程中仅保留高频元素，最终堆中即为结果（堆操作的时间复杂度为O(m log k)，m是不同元素的个数，m≤n）；</li>
<li>优势：时间复杂度为O(n + m log k)，优于O(n log n)（直接排序的复杂度），满足题目进阶要求。</li>
</ul>
</li>
<li><strong>具体步骤：</strong>
<ul>
<li><strong>统计频率</strong>：遍历数组，用HashMap记录每个元素的出现次数（键=元素，值=频率）；</li>
<li><strong>小顶堆筛选</strong>：遍历HashMap中的键值对，维护大小为k的小顶堆：
<ul>
<li>堆大小 &lt; k：直接将「元素+频率」加入堆；</li>
<li>堆大小 = k：若当前元素频率 &gt; 堆顶元素频率 → 弹出堆顶（频率最低的元素），加入当前元素；</li>
</ul>
</li>
<li><strong>提取结果</strong>：小顶堆中存储的是频率前k高的元素，但弹出顺序是「频率低→高」，需倒序存入结果数组。</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums){</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//定义小顶堆，比较逻辑是pair1[1]-pair2[1],即频率低的排在对头</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt; pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet()){</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k){  <span class="comment">// 堆大小不足k时，直接加入</span></span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {entry.getKey(),entry.getValue()});</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                  <span class="comment">// 当前元素频率 &gt; 堆顶元素频率（堆顶是当前k个元素中频率最低的）</span></span><br><span class="line">                <span class="keyword">if</span>(entry.getValue()&gt;pq.peek()[<span class="number">1</span>]){</span><br><span class="line">                    pq.poll();<span class="comment">// 弹出频率最低的元素</span></span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {entry.getKey(),entry.getValue()}); <span class="comment">// 加入当前高频元素</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 倒序存结果：小顶堆弹出的顺序是「频率低→高」，所以从后往前填</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><strong>核心知识点:</strong>
<ul>
<li><strong>哈希表的应用：</strong><code>HashMap</code>统计频率是处理「元素 - 频次」问题的基础，<code>getOrDefault</code>方法简化了「存在则 + 1，不存在则初始化为 1」的逻辑；</li>
<li><strong>小顶堆的核心价值：</strong>
<ul>
<li>维护 k 个高频元素，堆顶是当前 k 个元素中频率最低的，保证堆中始终是「频率前 k 高」的元素；</li>
<li>堆的插入 / 弹出操作复杂度为 O (log k)，相比直接排序（O (m log m)），当 k 远小于 m 时效率更高；</li>
</ul>
</li>
<li><strong>时间复杂度优化：</strong>
<ul>
<li>统计频率：O (n)；</li>
<li>堆操作：O (m log k)（m 是不同元素的个数，m≤n）；</li>
<li>总复杂度：O (n + m log k)，优于 O (n log n)，满足题目进阶要求。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希表</tag>
        <tag>堆</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2026/01/28/ValidParentheses/</url>
    <content><![CDATA[<h1>算法-有效的括号</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–有效的括号</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p>示例 1:</p>
<ul>
<li>输入: “()”</li>
<li>输出: true</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: “()[]{}”</li>
<li>输出: true</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: “(]”</li>
<li>输出: false</li>
</ul>
<p>示例 4:</p>
<ul>
<li>输入: “([)]”</li>
<li>输出: false</li>
</ul>
<p>示例 5:</p>
<ul>
<li>输入: “{[]}”</li>
<li>输出: true</li>
</ul>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><strong>核心逻辑</strong>：利用<strong>栈的「后进先出」特性</strong>匹配括号——左括号入栈，右括号匹配栈顶左括号，匹配成功则出栈，失败则直接返回false；</li>
<li><strong>具体步骤</strong>：
<ul>
<li>遍历字符串每个字符：
<ul>
<li>若为左括号（<code>(</code>/<code>{</code>/<code>[</code>）：将<strong>对应的右括号</strong>压入栈（简化后续匹配逻辑）；</li>
<li>若为右括号：
<ul>
<li>栈为空 → 无左括号匹配，返回false；</li>
<li>栈顶元素≠当前右括号 → 类型不匹配，返回false；</li>
<li>栈顶元素=当前右括号 → 匹配成功，弹出栈顶；</li>
</ul>
</li>
</ul>
</li>
<li>遍历结束后：栈为空则所有括号匹配成功，否则存在未闭合的左括号。</li>
</ul>
</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> {</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">             ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'('</span>){</span><br><span class="line">                deque.push(<span class="string">')'</span>);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'{'</span>){</span><br><span class="line">                deque.push(<span class="string">'}'</span>);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'['</span>){</span><br><span class="line">                deque.push(<span class="string">']'</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 碰到右括号时：如果栈为空（无左括号匹配），或栈顶不是当前右括号（匹配失败）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(deque.isEmpty()||deque.peek() != ch){</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 右括号匹配成功 → 弹出栈顶</span></span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                deque.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>有效的括号核心是<strong>栈+括号映射</strong>，利用栈的LIFO特性匹配嵌套括号；</li>
<li>关键技巧：左括号入栈时压入对应右括号，简化后续匹配逻辑；</li>
<li>面试需掌握「核心逻辑」「边界案例」「Deque替代Stack的原因」三个考点；</li>
<li>复杂度为O(n)（时间+空间）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数组环形队列</title>
    <url>/2024/08/19/arrayCircularQueue/</url>
    <content><![CDATA[<h1>数组环形队列</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——数组环形队列</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>对数据环形队列进行优化，解决普通数组队列不能重复使用数组的问题</li>
<li>通过取模来实现</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>调整front变量：将<strong>front指向队列的第一个元素</strong>，front赋初值为0</li>
<li>调整rear变量： 将<strong>rear指向队列的倒数第二个位置的元素</strong>，空出来的空间位置作为约定，rear赋初值为0</li>
<li>当队列满时，<strong>（rear + 1）% maxSize  =  front</strong>//算法</li>
<li>当队列空时，<strong>rear==front</strong></li>
<li>队列中有效的数据的个数（<strong>rear+maxSize-front）%maxSize</strong>//算法</li>
</ul>
<h2 id="修改ArrayQueue类实现">修改ArrayQueue类实现</h2>
<ul>
<li>
<p>修改ArrayQueue类</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleArray</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//队列头,指向队列第一元素，赋0值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾，指向队列倒数第二个元素，赋0值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//存储队列的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleArray</span><span class="params">(<span class="type">int</span> arrMaxSize)</span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>修改isFull（）方法判断队列是否为满</p>
<ul>
<li>
<p>当队列满时，<strong>（rear + 1）% maxSize  =  front</strong>//算法</p>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize == front;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>修改isEmpty（）方法判断队列是否空</p>
<ul>
<li>
<p>当队列空时，<strong>rear==front</strong></p>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> rear == front;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>修改addQueue（）方法添加数据</p>
<ul>
<li>
<p>先判断队列是否满，再添加数据进入队列</p>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">      <span class="comment">//判断队列是否满</span></span><br><span class="line">      <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;队列满了，不能再添加数据&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//直接将数据加入</span></span><br><span class="line">      arr[rear] = n;</span><br><span class="line">      <span class="comment">//将rear后移，考虑取模</span></span><br><span class="line">      rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>修改getQueue（）方法获取队列，出队列</p>
<ul>
<li>
<p>先判断队列是否空，若有数据，则将数据出队列</p>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取队列,出队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//front是指向队列的第一个元素</span></span><br><span class="line">    <span class="comment">// 1.将front对应的值保留到一个临时变量</span></span><br><span class="line">    <span class="comment">// 2.将front 后移</span></span><br><span class="line">    <span class="comment">// 3.将临时保存的变量返回</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arr[front];</span><br><span class="line">    front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>修改showQueue（）方法显示队列所有数据</p>
<ul>
<li>
<p>先判断队列是否为空，若存在数据就显示数据</p>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示队列所有数据</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;队列空没有数据&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//思路：从front开始遍历，遍历的多少个元素</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; front+size();i++) &#123;<span class="comment">//取模</span></span><br><span class="line">         System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i%maxSize,arr[i%maxSize]);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求出当前队列有效数据的个数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (rear+maxSize-front)%maxSize;<span class="comment">//取模</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>修改headQueue（）方法显示队列头数据</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示队列头数据</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空没有数据&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr[front];<span class="comment">//ArrayQueue中是front+1</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>CircleArrayDemo类测试</p>
<ul>
<li>
<p>代码实现与ArrayQueueDemo类大体相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试环形数据队列&quot;</span>);</span><br><span class="line">        <span class="type">CircleArray</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArray</span>(<span class="number">3</span>);  <span class="comment">//修改为环形队列</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):&quot;</span>);</span><br><span class="line">            key =scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>,res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>,res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li>
<p>addQueue（）方法</p>
<p><img src="/2024/08/19/arrayCircularQueue/arrayCircularQueue%5Ca.png" alt></p>
</li>
<li>
<p>getQueue（）方法</p>
<p><img src="/2024/08/19/arrayCircularQueue/arrayCircularQueue%5Cg.png" alt></p>
</li>
<li>
<p>showQueue（）方法</p>
<p><img src="/2024/08/19/arrayCircularQueue/arrayCircularQueue%5Cs.png" alt></p>
</li>
<li>
<p>headQueue（）方法</p>
<p><img src="/2024/08/19/arrayCircularQueue/arrayCircularQueue%5Ch.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2024/10/09/bubbleSort/</url>
    <content><![CDATA[<h1>冒泡排序</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法——冒泡排序</p>
<span id="more"></span>
</li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>冒泡排序是最简单的交换排序，通过俩俩比较进行交换</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>
<p>用两层for循环解决</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">bubbleSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> arr[]={<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">99</span>,<span class="number">44</span>,<span class="number">66</span>,<span class="number">1</span>};</span><br><span class="line">        <span class="type">int</span> temp;<span class="comment">//辅助变量，交换值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//优化，判断是否发生排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) {<span class="comment">//比较轮数，-1是指不与自身排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-i; j++) {<span class="comment">//每一轮比较次数</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>]){<span class="comment">//大于小于号表示按照升序排序还是降序排序</span></span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++){</span><br><span class="line">         System.out.println(arr[i]);</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录</title>
    <url>/2024/01/27/bwl/</url>
    <content><![CDATA[<h1>备忘录</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>记录一些容易忘记的内容</p>
</li>
<li>
<p>如：函数、启动命令等</p>
<span id="more"></span>
</li>
</ul>
<h3 id="常用函数">常用函数</h3>
<ul>
<li>
<p><code>substring(startIndex, endIndex)</code> 的规则是：截取从 <code>startIndex</code>（包含）到 <code>endIndex</code>（不包含）的子串。</p>
</li>
<li>
<p><code>resultMap="BaseResultMap"</code> 是MyBatis中非常重要的一个配置，用来<strong>定义Java对象属性与数据库字段的映射关系</strong>。</p>
</li>
<li>
<p><code>::</code> 是 <strong>PostgreSQL 的类型转换运算符</strong>，它用来将一个值从一种数据类型转换为另一种数据类型。</p>
<ul>
<li>
<pre><code class="language-java">&lt;select id="selectAll" resultMap="BaseResultMap"&gt;
    SELECT id,
           name,
           description,
           system_prompt,
           model,
           allowed_tools::text AS allowed_tools,
           allowed_kbs::text   AS allowed_kbs,
           chat_options::text  AS chat_options,
           created_at,
           updated_at
    FROM agent
    ORDER BY created_at DESC
&lt;/select&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* Spring 的`Assert`工具类，用于参数合法性校验；</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Assert.notNull(agent, "Agent cannot be null");</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>PATCH：只传递需要修改的字段，未传递的字段保持原有值；</p>
</li>
<li>
<p>return doubleStr.substring(1, doubleStr.length() - 1).contains(s);</p>
</li>
<li>
<p>// 1. doubleStr = s + s （拼接两个原字符串）</p>
</li>
<li>
<p>// 2. substring(1, doubleStr.length() - 1)：截取字符串，去掉首尾各1个字符</p>
</li>
<li>
<p>// 3. contains(s)：判断截取后的字符串是否包含原字符串s</p>
</li>
</ul>
]]></content>
      <categories>
        <category>札记</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>链表模拟栈</title>
    <url>/2024/10/08/linkdist-stack/</url>
    <content><![CDATA[<h1>链表模拟栈</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——链表模拟栈</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>
<p>定义一个<strong>HeroNode</strong>类，每一个<strong>HeroNode</strong>对象就是一个节点</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，重写toString方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode{"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", value="</span> + value +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>链表模拟栈<strong>Linkdist_stack</strong>类</p>
<ul>
<li>
<p>初始化一个头节点<strong>head</strong>，不存放数据</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(-<span class="number">1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>top</strong>为栈顶指针，初始化为**-1**</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span>-<span class="number">1</span>;<span class="comment">//栈顶指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>maxLength</strong>为栈的最大容量</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxLength;<span class="comment">//定义最大长度</span></span><br><span class="line"><span class="comment">//设置栈最大容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Linkdist_stack</span><span class="params">(<span class="type">int</span> maxLength)</span> {</span><br><span class="line">    <span class="built_in">this</span>.maxLength = maxLength;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>判断栈是否为空<strong>isEmpty</strong></p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>{</span><br><span class="line">   <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>判断栈是否满<strong>isFull</strong></p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> top&gt;=maxLength-<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用倒插法入栈<strong>push</strong></p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>{<span class="comment">//为新节点传入新值</span></span><br><span class="line"></span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">heroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(top,value);</span><br><span class="line">     <span class="keyword">if</span> (isFull()){</span><br><span class="line">         System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     }</span><br><span class="line">     top++;</span><br><span class="line">     <span class="keyword">if</span>(head.next==<span class="literal">null</span>){<span class="comment">//说明没有新节点，可以直接添加</span></span><br><span class="line">         head.next = heroNode;</span><br><span class="line">     }<span class="keyword">else</span>{</span><br><span class="line">         heroNode.next = head.next;</span><br><span class="line">         head.next = heroNode;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>出栈<strong>pop</strong></p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"栈空，没有数据"</span>);</span><br><span class="line">    }</span><br><span class="line">   <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">    head.next = head.next.next;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>显示<strong>show</strong></p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()){</span><br><span class="line">        System.out.println(<span class="string">"栈空没有数据"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="keyword">if</span> (temp.next==<span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>测试类 <strong>linkdist_stackDemo</strong></p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">linkdist_stackDemo</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//测试一下LinkedListStack是否正确</span></span><br><span class="line">        <span class="comment">//先创建一个LinkedListStack对象表示栈</span></span><br><span class="line">        <span class="type">Linkdist_stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Linkdist_stack</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"show:表示显示栈"</span>);</span><br><span class="line">        System.out.println(<span class="string">"exit:表示退出程序"</span>);</span><br><span class="line">        System.out.println(<span class="string">"push:表示添加数据到栈"</span>);</span><br><span class="line">        System.out.println(<span class="string">"pop:表示从栈中取出数据"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop) {</span><br><span class="line">            System.out.print(<span class="string">"\n请输入你的选择:"</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">                    stack.show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">                    System.out.print(<span class="string">"请输入一个数:"</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                        System.out.println(<span class="string">"出栈的数据是："</span> + res);</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="本章重点">本章重点</h2>
<ul>
<li>
<p>单链表的倒插法的算法</p>
<ul>
<li>
<p>图解倒插法</p>
</li>
<li>
<p>算法：</p>
<ul>
<li><strong>heroNode.next = head.next;</strong><br>
<strong>head.next = heroNode;</strong></li>
</ul>
<p><img src="/2024/10/08/linkdist-stack/D:%5Cseeya-ch.github.io%5Csource_posts%5Clinkdist-stack%5C%E5%80%92%E6%8F%92%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>双向链表</title>
    <url>/2024/09/08/doubleLinkedList/</url>
    <content><![CDATA[<h1>双向链表</h1>
<h2 id="双向链表的增删查改">双向链表的增删查改</h2>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——双向链表</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>
<p>双向链表遍历方法与单向链表相同，不过双向链表可以向前和向后查找</p>
</li>
<li>
<p>添加，默认添加到最后</p>
<ul>
<li>先找到双向链表的最后节点</li>
<li><strong>temp.next = newHeroNode</strong></li>
<li><strong>newHeroNode.pre = temp</strong></li>
</ul>
</li>
<li>
<p>修改，与单链表相同</p>
</li>
<li>
<p>删除</p>
<ul>
<li>双向链表可以自我删除</li>
<li>直接找到要删除的节点temp</li>
<li><strong>temp.pre.next = temp.next</strong></li>
<li><strong>temp.next.pre = temp.pre</strong></li>
</ul>
</li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>使用双向链表实现–水浒传排行榜管理</li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li>与单链表类似</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<ul>
<li>
<p>修改单链表中HeroNode类</p>
<ul>
<li>
<p>增加pre变量指向链表中上一个节点</p>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next;<span class="comment">//指向下个节点，默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre;<span class="comment">//指向上个节点，默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode2</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> {</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode{"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", nickname='"</span> + nickname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>遍历</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历双向链表，与单链表一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//因为头节点不能动，所以需要辅助变量遍历</span></span><br><span class="line">    <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">//判断链表是否最后</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//输出节点的信息</span></span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="comment">//将节点后移</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>添加</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode2 heroNode)</span> {</span><br><span class="line">    <span class="comment">//当不考虑编号顺序时</span></span><br><span class="line">    <span class="comment">//先找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//将最后节点next指向新的节点</span></span><br><span class="line">    <span class="comment">//因为head头节点不能动，所以需要辅助遍历temp</span></span><br><span class="line">    <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//遍历链表找到最后</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">//代表找到链表的最后</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//找不到就将temp后移，直至找到退出循环</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//当退出循环时，temp指向链表的最后</span></span><br><span class="line">    <span class="comment">//形成双向链表</span></span><br><span class="line">    temp.next = heroNode;</span><br><span class="line">    heroNode.pre = temp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>修改</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改双向链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upadate</span><span class="params">(HeroNode2 newHeroNode)</span> {</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">    <span class="comment">//定义一个辅助变量temp</span></span><br><span class="line">    <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//已经遍历完链表了</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (temp.no == newHeroNode.no) {</span><br><span class="line">            flag = <span class="literal">true</span>;<span class="comment">//找到</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据flag判断是否找到要修改的节点</span></span><br><span class="line">    <span class="keyword">if</span> (flag) {</span><br><span class="line">        temp.name = newHeroNode.name;</span><br><span class="line">        temp.nickname = newHeroNode.nickname;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从双向链表删除节点</span></span><br><span class="line"><span class="comment">//双向链表可以自我删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>{</span><br><span class="line">    <span class="comment">//判断当前链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span>){{</span><br><span class="line">        System.out.println(<span class="string">"链表为空，不能删除"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;<span class="comment">//辅助变量直接指向要删除的节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//判断是否找到要删除节点的标志</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//到了链表最后</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(temp.no == no){<span class="comment">//找到要删除的节点</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        temp = temp.next;<span class="comment">//后移</span></span><br><span class="line">    }<span class="keyword">if</span>(flag){<span class="comment">//找到执行</span></span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) {</span><br><span class="line">                temp.next.pre = temp.pre;<span class="comment">//存在风险，如果是最后一个节点，不需要执行这段代码，否则会出现空指针异常</span></span><br><span class="line">            }</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{<span class="comment">//没有找到执行</span></span><br><span class="line">            System.out.printf(<span class="string">"要删除的节点%d不存在\n"</span>,no);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>小技巧</title>
    <url>/2024/07/31/paper/</url>
    <content><![CDATA[<h1>小技巧</h1>
<span id="more"></span>截断文章，让首页不显示所有文章
<p>哈哈哈哈</p>
]]></content>
      <categories>
        <category>札记</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2024/09/08/singLinkedList-02/</url>
    <content><![CDATA[<h1>单链表（其三）</h1>
<h2 id="单向链表的练习">单向链表的练习</h2>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——单向链表</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="问题（一）">问题（一）</h2>
<ul>
<li>获得单链表的节点的个数，不需要统计头节点</li>
</ul>
<h2 id="解决步骤">解决步骤</h2>
<ul>
<li>
<p>判断链表是否为空，是的话返回0</p>
</li>
<li>
<p>设置辅助变量cur指向<strong>head.next</strong></p>
</li>
<li>
<p>设置<strong>length</strong>计算节点个数</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得单链表的节点的个数，不需要统计头节点</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span>{</span><br><span class="line">       <span class="keyword">if</span>(head.next == <span class="literal">null</span>){<span class="comment">//判断是否为空列表，是的话返回0</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;<span class="comment">//辅助变量cur</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//计算节点个数</span></span><br><span class="line">       <span class="keyword">while</span>(cur != <span class="literal">null</span>){<span class="comment">//若cur等于null，则代表到达单链表尾部</span></span><br><span class="line">           length++;</span><br><span class="line">           cur=cur.next;<span class="comment">//遍历</span></span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> length;</span><br><span class="line">   }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="问题（二）">问题（二）</h2>
<ul>
<li>查找单链表中倒数第k个节点</li>
</ul>
<h2 id="解决步骤-2">解决步骤</h2>
<ul>
<li>
<p>编写一个方法，接收<strong>head节点</strong>，同时接收一个<strong>index</strong></p>
</li>
<li>
<p><strong>index表示是倒数地index个节点</strong></p>
</li>
<li>
<p>先把链表从头遍历到尾，得到链表的总长度</p>
</li>
<li>
<p>得到<strong>size</strong>后，我们从链表的第一个开始遍历（<strong>size-index</strong>）个，就可以得到</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找单链表中倒数第k个节点</span></span><br><span class="line"> <span class="comment">//1.编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"> <span class="comment">//2.index表示是倒数地index个节点</span></span><br><span class="line"> <span class="comment">//3.先把链表从头遍历到尾，得到链表的总长度</span></span><br><span class="line"> <span class="comment">//4.得到size后，我们从链表的第一个开始遍历（size-index）个，就可以得到</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head,<span class="type">int</span> index)</span>{</span><br><span class="line">     <span class="keyword">if</span>(head.next == <span class="literal">null</span> ){<span class="comment">//判断链表是否为空</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);<span class="comment">//调用getLength方法得到链表长度</span></span><br><span class="line">     <span class="keyword">if</span>(index&lt;=<span class="number">0</span>||index&gt;size){  <span class="comment">//如果要查找的数小于0或者大于链表长度，则返回空</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size-index;i++){</span><br><span class="line">         cur = cur.next;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> cur;</span><br><span class="line"> }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="问题（三）">问题（三）</h2>
<ul>
<li>将单链表反转</li>
</ul>
<h2 id="解决步骤-3">解决步骤</h2>
<ul>
<li>
<p>先定义一个新节点<strong>reverseHead = new HeroNode</strong></p>
</li>
<li>
<p>从头到尾遍历原来的链表，每遍历一个节点就将它取出，放在新链表的最前端</p>
</li>
<li>
<p>从原来的链表的<strong>head.next=reverseHead.next</strong></p>
</li>
<li>
<p><strong>head节点</strong></p>
<ul>
<li>不存放具体数据</li>
<li>作用就是表示单链表头的next</li>
</ul>
</li>
<li>
<p><strong>reversHead节点</strong></p>
<ul>
<li>不存放具体数据</li>
<li>作用就是表示单链表头的next</li>
</ul>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表的反转</span></span><br><span class="line"><span class="comment">//1.先定义一个新节点reverseHead = new HeroNode</span></span><br><span class="line"><span class="comment">//2.从头到尾遍历原来的链表，每遍历一个节点就将它取出，放在新链表的最前端</span></span><br><span class="line"><span class="comment">//3.从原来的链表的head.next=reverseHead.next</span></span><br><span class="line"><span class="comment">//head节点</span></span><br><span class="line"><span class="comment">//1.不存放具体数据</span></span><br><span class="line"><span class="comment">//2.作用就是表示单链表头的next</span></span><br><span class="line"><span class="comment">//reversHead节点</span></span><br><span class="line"><span class="comment">//1.不存放具体数据</span></span><br><span class="line"><span class="comment">//2.作用就是表示单链表头的next</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversetList</span><span class="params">(HeroNode head)</span>{</span><br><span class="line">    <span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span>||head.next.next == <span class="literal">null</span>){</span><br><span class="line">        System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//定义辅助变量，遍历原链表</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//指向当前节点cur的下节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//遍历原链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>){</span><br><span class="line">        next = cur.next;<span class="comment">//先保存当前节点的下一节点</span></span><br><span class="line">        cur.next = reverseHead.next;<span class="comment">//将cur的下一节点指向新的链表的最前端</span></span><br><span class="line">        reverseHead.next = cur;<span class="comment">//将cur加到新的链表上</span></span><br><span class="line">        cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//将head.next指向reverHead.next,实现单链表的反转</span></span><br><span class="line">    head.next = reverseHead.next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="问题（四）">问题（四）</h2>
<ul>
<li>从尾到头打印单链表</li>
</ul>
<h2 id="解决步骤-4">解决步骤</h2>
<ul>
<li>
<p>方法一：逆序打印单链表，这样的问题：会破坏当前链表，不建议</p>
</li>
<li>
<p>方法二：可以利用栈这个数据结构，将各个节点压入栈中，利用栈的先进后出的特点，实现逆序打印</p>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从尾到头打印单链表</span></span><br><span class="line">  <span class="comment">//思路：1.逆序打印单链表，这样的问题：会破坏当前链表，不建议</span></span><br><span class="line">  <span class="comment">//     2.可以利用栈这个数据结构，将各个节点压入栈中，利用栈的先进后出的特点，实现逆序打印</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span>{</span><br><span class="line">     <span class="comment">//如果当前链表为空</span></span><br><span class="line">     <span class="keyword">if</span>(head.next == <span class="literal">null</span>){</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     }</span><br><span class="line">     Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">//创建一个栈，将各个节点压入栈中</span></span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">     <span class="keyword">while</span>(cur!=<span class="literal">null</span>){</span><br><span class="line">         stack.push(cur);</span><br><span class="line">         cur= cur.next;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>){</span><br><span class="line">         System.out.println(stack.pop());<span class="comment">//出栈打印，栈的特点是先进后出</span></span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2024/09/04/singleLinkedList-01/</url>
    <content><![CDATA[<h1>单链表（其二）</h1>
<h2 id="单向链表的修改和删除">单向链表的修改和删除</h2>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——单向链表</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>
<p>使用带head头的单向链表实现–水浒传排行榜管理</p>
</li>
<li>
<p>完成单链表的修改和删除</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>
<p>修改：</p>
<ul>
<li>修改节点信息，根据编号来修改，即**no（编号）<strong>不能改，根据</strong>newHeroNode的no（编号）**来修改即可</li>
<li>判断链表是否为空</li>
<li>找到需要修改的节点的编号<strong>no</strong></li>
<li>定义一个辅助变量<strong>temp</strong>，设置<strong>flag</strong>变量判断是否找到该节点</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>先找到需要删除的节点的前一个节点<strong>temp</strong></li>
<li><strong>temp.next = temp.next.next</strong></li>
<li>被删除的节点，不会被其它引用，会直接被回收</li>
</ul>
</li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li>
<p>修改</p>
<ul>
<li>
<p>先判断链表是否为空</p>
</li>
<li>
<p>根据<strong>no</strong>编号，找到需要修改的节点</p>
</li>
<li>
<p>定义一个辅助变量<strong>temp</strong>和<strong>flag</strong>变量</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upadate</span><span class="params">(HeroNode newHeroNode)</span> {</span><br><span class="line">       <span class="comment">//判断链表是否为空</span></span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) {</span><br><span class="line">           System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">       <span class="comment">//定义一个辅助变量temp</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">           <span class="keyword">if</span> (temp == <span class="literal">null</span>) {</span><br><span class="line">               <span class="keyword">break</span>;<span class="comment">//已经遍历完链表了</span></span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (temp.no == newHeroNode.no) {</span><br><span class="line">               flag = <span class="literal">true</span>;<span class="comment">//找到</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           }</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       }</span><br><span class="line">     <span class="comment">// 根据flag判断是否找到要修改的节点</span></span><br><span class="line">       <span class="keyword">if</span> (flag) {</span><br><span class="line">           temp.name = newHeroNode.name;</span><br><span class="line">           temp.nickname = newHeroNode.nickname;</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="comment">//没有找到</span></span><br><span class="line">           System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>
<p><strong>head</strong>不能动，需要辅助变量<strong>temp</strong>节点找到删除节点的前一节点</p>
</li>
<li>
<p>比较时是<strong><a href="http://temp.next.no">temp.next.no</a></strong>和删除节点的<strong>no</strong>比较</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表</span></span><br><span class="line">    <span class="comment">//head不能动，需要辅助变量temp节点找到删除节点的前一个节点</span></span><br><span class="line"><span class="comment">//    比较时，是temp.next.no和删除节点的no比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>{</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//代表是否找到要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="literal">null</span>){<span class="comment">//已经到了链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==no){</span><br><span class="line">             <span class="comment">//找到删除节点的前节点</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        } <span class="keyword">if</span>(flag){</span><br><span class="line">            <span class="comment">//可以删除</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li>
<p>修改</p>
<p><img src="/2024/09/04/singleLinkedList-01/singleLinkedList-01%5C%E4%BF%AE%E6%94%B9.png" alt></p>
</li>
<li>
<p>删除</p>
<p><img src="/2024/09/04/singleLinkedList-01/singleLinkedList-01%5C%E5%88%A0%E9%99%A4.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2024/09/03/singleLinkedList/</url>
    <content><![CDATA[<h1>单链表（其一）</h1>
<h2 id="单向链表的创建和添加">单向链表的创建和添加</h2>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——单向链表</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>链表：
<ul>
<li>链表以节点的方式进行存储</li>
<li>每个节点包含<strong>data域</strong>和<strong>next域</strong>
<ul>
<li><strong>next域指向下一节点</strong></li>
</ul>
</li>
<li>链表的各个节点不一点按顺序存储</li>
<li>链表分带头节点和没有带头节点的链表</li>
</ul>
</li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>使用带head头的单向链表实现–水浒传排行榜管理
<ul>
<li>完成对人物的增删改查</li>
<li>第一种方法在添加人物时，直接添加到链表的尾部</li>
<li>第二种方法在添加人物时，根据排名将人物插入到指点位置（如果有这个排名则添加失败，并给出提示）</li>
</ul>
</li>
</ul>
<h2 id="思路分析">思路分析</h2>
<ul>
<li>
<p>相关数据</p>
<ul>
<li><strong>int no，String name，String nickName ，HeroNode next</strong></li>
<li><strong>head节点</strong>
<ul>
<li>不存放具体的数据</li>
<li>作用就是表示单链表头</li>
<li><strong>next</strong>–指向下个节点</li>
</ul>
</li>
<li><strong>HeroNode节点</strong>
<ul>
<li>数据</li>
<li>next域</li>
</ul>
</li>
</ul>
</li>
<li>
<p>不需要按照编号顺序添加（创建）</p>
<ul>
<li>先创建一个<strong>head头节点</strong>，作用就是表示单链表的头</li>
<li>后面我们添加每一个节点，就直接加入到链表的最后</li>
</ul>
</li>
<li>
<p>遍历</p>
<ul>
<li>通过一个辅助遍历，帮助遍历整个链表</li>
</ul>
</li>
<li>
<p>需要按照编号顺序添加</p>
<ul>
<li>
<p>首先找到新添加节点的位置，通过**辅助变量(temp)**找到</p>
</li>
<li>
<p><strong>新的节点. next = temp.next</strong></p>
</li>
<li>
<p><strong>将temp.next = 新的节点</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li>
<p>定义一个HeroNode类，每个HeroNode对象就是一个节点</p>
<ul>
<li>
<p>相关属性</p>
<ul>
<li>int no，String name，String nickname HeroNode next；</li>
</ul>
</li>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> {</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//为了显示方便，重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode{"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", nickname='"</span> + nickname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>定义一个SingleLinkedList类------管理我们的人物</p>
</li>
<li>
<p>第一种方法，直接添加数据到尾部</p>
<ul>
<li>
<p>先初始化一个头节点，头节点不能动，不能存放数据</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>当不考虑编号顺序时，先找到当前链表的最后节点，将最后节点next指向新的节点，因为head头节点不能动，所以需要辅助便利temp遍历</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span>{</span><br><span class="line">        <span class="comment">//当不考虑编号顺序时</span></span><br><span class="line">        <span class="comment">//先找到当前链表的最后节点</span></span><br><span class="line">        <span class="comment">//将最后节点next指向新的节点</span></span><br><span class="line">        <span class="comment">//因为head头节点不能动，所以需要辅助遍历temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表找到最后</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//代表找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="literal">null</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//找不到就将temp后移，直至找到后退出循环</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//当退出循环时，temp指向链表的最后</span></span><br><span class="line">        <span class="comment">//将这个节点的next指向新节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第二种方法，按照顺序添加人物插入链表</p>
<ul>
<li>
<p>先初始化一个头节点，头节点不能动，不能存放数据</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>头节点不能动，所以我们需要一个辅助变量temp来寻找添加的位置，因为是单链表，我们找的temp是位于添加位置的前一个节点，否则插入不了</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span>{</span><br><span class="line">        <span class="comment">//头节点不能动，所以我们需要一个辅助变量来寻找添加的位置</span></span><br><span class="line">        <span class="comment">//因为是单链表，我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//flag标志添加的符号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="literal">null</span>){<span class="comment">//表示已经找到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt; heroNode.no){<span class="comment">//位置找到，就是temp的后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no ==heroNode.no){<span class="comment">//编号存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            temp = temp.next;<span class="comment">//后移，遍历当前的链表</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">            <span class="keyword">if</span>(flag){<span class="comment">//不能添加，编号存在</span></span><br><span class="line">        System.out.println(<span class="string">"存在"</span>+heroNode.no);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//插入链表中，temp的后面</span></span><br><span class="line">        heroNode.next = temp.next;</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>显示链表List方法</p>
<ul>
<li>
<p>先判断链表是否为空，同时需要辅助变量</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">//显示链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>){</span><br><span class="line">        System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//因为头节点不能动，所以需要辅助变量遍历</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">        <span class="comment">//判断链表是否最后</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//输出节点的信息</span></span><br><span class="line">        System.out.println(temp);</span><br><span class="line">      <span class="comment">//将节点后移</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>主类SingLinkedListDemo：测试</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingLinkedListDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">"宋江"</span>,<span class="string">"及时雨"</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">"卢俊义"</span>,<span class="string">"玉麒麟"</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">"吴用"</span>,<span class="string">"智多星"</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">"林冲"</span>,<span class="string">"豹子头"</span>);</span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        <span class="comment">//第一种方法加入</span></span><br><span class="line">       <span class="comment">/* singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(heroNode4);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(heroNode2);*/</span></span><br><span class="line">        <span class="comment">//第二种方法加入，按照顺序加入</span></span><br><span class="line">        System.out.println(<span class="string">"==================================="</span>);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li>
<p>第一种方法</p>
<p><img src="/2024/09/03/singleLinkedList/singleLinkedList%5C01.png" alt></p>
</li>
<li>
<p>第二种方法</p>
<p><img src="/2024/09/03/singleLinkedList/singleLinkedList%5C02.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏数组</title>
    <url>/2024/08/13/sparseArray/</url>
    <content><![CDATA[<h1>稀疏数组</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——稀疏数组</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>稀疏数组是一种用于存储和处理多维数组中大部分元素为0（或者同一个值）的数据结构。</li>
<li>稀疏数组的处理方法:
<ul>
<li>记录数组一共有几行几列，有几个不同的值。</li>
<li>把不同值的元素的行、列和值分别存入稀疏数组中。</li>
</ul>
</li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>将原始二维数组转化为稀疏数组
<ul>
<li>原始二维数组（11*11）</li>
<li>稀疏数组（3*3）</li>
</ul>
</li>
</ul>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="391.968ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 173250 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtable"><g data-mml-node="mtr"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(17250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(18750,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(20250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(21750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(23250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(24750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(26250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(27750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(29250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(30750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(33000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(34500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(36000,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mtd" transform="translate(37500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(39000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(40500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(42000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(43500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(45000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(46500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(48750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(50250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(51750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(53250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(54750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(56250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(57750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(59250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(60750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(62250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(64500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(66000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(67500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(69000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(70500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(72000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(73500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(75000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(76500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(78000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(80250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(81750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(83250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(84750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(86250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(87750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(89250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(90750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(92250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(93750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(96000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(97500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(99000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(100500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(102000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(103500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(105000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(106500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(108000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(109500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(111750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(113250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(114750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(116250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(117750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(119250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(120750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(122250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(123750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(125250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(127500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(129000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(130500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(132000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(133500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(135000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(136500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(138000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(139500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(141000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(143250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(144750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(146250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(147750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(149250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(150750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(152250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(153750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(155250,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(156750,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(159000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(160500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(162000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(163500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(165000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(166500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(168000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(169500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(171000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(172500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g></g></g></g></g></g></svg></mjx-container></p>
<table>
<thead>
<tr>
<th>行</th>
<th>列</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td>11</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
</tbody>
</table>
<h2 id="步骤">步骤</h2>
<ol>
<li>
<p>先创建一个11*11的二维数组，0：表示没有棋子，1：表示黑子，2：表示白子</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始棋盘</span></span><br><span class="line">        System.out.println(<span class="string">"原始棋盘"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : chessArr1){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> date : row){</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,date);</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>将二维数据转为稀疏数组</p>
<ul>
<li>
<p>2.1.先遍历二维数组，得到非0个数。</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) {</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) {</span><br><span class="line">             <span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>){</span><br><span class="line">                 sum++;</span><br><span class="line">             }</span><br><span class="line">         }</span><br><span class="line">     }</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>2.2.创建稀疏数组，给稀疏数组赋值</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span> [sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>2.3.遍历二维数组，将其中非0数赋给稀疏数组</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录第几个非0数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) {</span><br><span class="line">        <span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>){</span><br><span class="line">            count++;</span><br><span class="line">            sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">            sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">            sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
</li>
<li>
<p>2.4.输出稀疏数组</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"得到的稀疏数组"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) {</span><br><span class="line">           System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">       }</span><br><span class="line">       System.out.println();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>将稀疏数组恢复成二维数组</p>
<ul>
<li>
<p>3.1.先读取稀疏数组第一行，创建原始的二维数组</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>3.2.再读取稀疏数组后几行，赋给原始的二维数组</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt; sparseArr.length ; i++) {<span class="comment">//因为第一行是用来创建原始二维数组,所以从第二行开始</span></span><br><span class="line">    chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">2</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>3.3.恢复后的棋盘</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span>[] row : chessArr1){</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> date : row){</span><br><span class="line">        System.out.printf(<span class="string">"%d\t"</span>,date);</span><br><span class="line">    }</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li>
<p>原始棋盘图</p>
<ul>
<li><img src="/2024/08/13/sparseArray/0.1.png" alt></li>
</ul>
</li>
<li>
<p>稀疏数组图</p>
<ul>
<li>
<img src="/2024/08/13/sparseArray/0.3.png" style="zoom:150%;">
</li>
</ul>
</li>
<li>
<p>恢复棋盘图</p>
<ul>
<li><img src="/2024/08/13/sparseArray/0.2.png" alt></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2026/01/19/sumOfTwoNumbers/</url>
    <content><![CDATA[<h1>算法-两数之和</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>算法–两数之和</p>
</li>
<li>
<p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>使用哈希法的时候：当我们需要查询一个元素是否在集合里的时候</li>
<li>本题需要一个集合来存放我们遍历后的元素，在遍历数组的时候再询问这个集合，看元素是否遍历过</li>
<li>map是一种key value的存储结构，key = 数值，value = 下标</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">         <span class="type">int</span>[] r = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];<span class="comment">//储存两个下标</span></span><br><span class="line">         <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">         }</span><br><span class="line">         Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++){</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> target - nums[i]; <span class="comment">//通过相减得出另一个数是什么</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(t)){ <span class="comment">// 关键判断：HashMap中是否存在补数t（说明之前遍历过这个数）</span></span><br><span class="line">                    r[<span class="number">1</span>] = i;</span><br><span class="line">                    r[<span class="number">0</span>] = map.get(t);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                map.put(nums[i],i);  <span class="comment">// 若补数不存在，把当前元素的“数值-下标”存入HashMap，供后续元素查询</span></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>为什么会想到用哈希表
<ul>
<li>当我们需要查询一个元素是否在集合里的时候</li>
</ul>
</li>
<li>哈希表为什么用map
<ul>
<li>Set 只能存 “值”，只能判断补数是否存在；而我们需要同时获取补数的下标，Map 的 “键值对” 结构刚好能满足 “存数值 + 存下标” 的需求。</li>
</ul>
</li>
</ul>
<ul>
<li>本题map是用来存什么的
<ul>
<li>存已遍历过的数组元素及其下标，相当于 “遍历账本”，供后续元素快速查补数</li>
</ul>
</li>
<li>map中的key和value用来存什么的
<ul>
<li>key：数值</li>
<li>value：数组下标</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2024/10/01/stack/</url>
    <content><![CDATA[<h1>栈</h1>
<h2 id="背景">背景</h2>
<ul>
<li>
<p>数据结构——栈</p>
</li>
<li>
<p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span>
</li>
</ul>
<h2 id="介绍">介绍</h2>
<ul>
<li>
<p>栈是一个<strong>先进后出</strong>的有序列表</p>
</li>
<li>
<p>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除一端，为变化的一端，称为<strong>栈顶（Top）</strong>；另一端为固定端，称为<strong>栈底（Bottom）</strong></p>
</li>
<li>
<p>先进的元素后删除，后进的元素先删除</p>
</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>
<p>使用数组模拟栈</p>
</li>
<li>
<p>定义一个<strong>top</strong>来表示栈顶，初始化为-1</p>
</li>
<li>
<p>入栈操作，当有数据入栈时，<strong>top++；stack[top] = data;</strong></p>
</li>
<li>
<p>出栈操作，<strong>int value = stack [top];top–,return value;</strong></p>
</li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li>
<p>创建一个测试类ArrayStackDemo</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span><span class="string">" "</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(loop){</span><br><span class="line">            System.out.println(<span class="string">"show:"</span>);</span><br><span class="line">            System.out.println(<span class="string">"exit:"</span>);</span><br><span class="line">            System.out.println(<span class="string">"push:"</span>);</span><br><span class="line">            System.out.println(<span class="string">"pop:"</span>);</span><br><span class="line">            System.out.println(<span class="string">"请输入"</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key){</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入一个数："</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">"出栈的数据是%d\n"</span>,res);</span><br><span class="line">                    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>定义一个ArrayStack类</p>
<ul>
<li>
<p>栈的大小</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>数组模拟栈，数据放在改数组</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] stack;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>top表示栈顶，初始化为-1</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;   </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>栈满</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> top == maxSize -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>栈空</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>入栈</p>
<ul>
<li>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>{</span><br><span class="line">    <span class="comment">//判断栈是否满</span></span><br><span class="line">    <span class="keyword">if</span>(isFull()){</span><br><span class="line">        System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    top++;</span><br><span class="line">    stack[top] = value;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>出栈</p>
<ul>
<li>
<pre><code class="language-java"> //出栈pop，将栈顶数据返回
    public int pop(){
     //先判断栈是否空
        if(isEmpty()){
            //抛出异常
             throw new RuntimeException("栈空");
        }
        int value = stack[top];
        top--;
        return value;
    }
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 遍历栈</span><br><span class="line"></span><br><span class="line">  * 代码实现</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">    //遍历栈，遍历时要从栈顶开始</span><br><span class="line">       public void list(){</span><br><span class="line">          if(isEmpty()){</span><br><span class="line">              System.out.println("栈空没有数据");</span><br><span class="line">              return;</span><br><span class="line">          }</span><br><span class="line">          //从栈顶开始显示数据</span><br><span class="line">           for(int i=top;i&gt;=0;i--){</span><br><span class="line">               System.out.printf("stack[%d]==%d\n",i,stack[i]);</span><br><span class="line">           }</span><br><span class="line">       }</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
</search>
