<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组队列</title>
    <url>/2024/08/19/ArrayQueue/</url>
    <content><![CDATA[<h1 id="数组队列">数组队列</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——数组队列</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>队列是一个有序列表，可以用数组或链表实现。</li>
<li>遵循先入先出原则：
<ul>
<li>先存入的数据，先取出，后存入的数据后取出。</li>
</ul></li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>使用数组模拟队列实现</li>
<li>相关数据：
<ul>
<li><strong>maxSize</strong>：该队列的最大容量</li>
<li><strong>front</strong>：头指针，指向队列头部，指向队列头的前一个位置，随数据的输出而改变，初始值为-1</li>
<li><strong>rear</strong>：
尾指针，指向队列尾部，指向队列尾，随数据的输入而改变，初始值为-1</li>
</ul></li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li><p>创建 ArrayQueue类</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//存储队列的数组</span></span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span>{</span><br><span class="line">    maxSize = arrMaxSize;</span><br><span class="line">    arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    front = -<span class="number">1</span>;<span class="comment">//指向队列头部，指向队列头的前一个位置</span></span><br><span class="line">    rear = -<span class="number">1</span>;<span class="comment">// 指向队列尾部，指向队列尾</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>addQueue方法：将数据存入队列中</strong></p>
<ul>
<li><p>思路分析：</p>
<ul>
<li><p>rear == front 时队列为空</p></li>
<li><p>将尾指针往后移：rear+1</p></li>
<li><p>rear == maxSize-1时 队列满不能再添加数据</p></li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">      <span class="comment">//判断队列是否满</span></span><br><span class="line">      <span class="keyword">if</span>(isFull()){</span><br><span class="line">          System.out.println(<span class="string">"队列满了，不能再添加数据"</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      }</span><br><span class="line">      arr[++rear] = n;<span class="comment">//先对rear+1，再进行赋值</span></span><br><span class="line">  }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>isFull方法： 判断队列是否满</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> rear == maxSize-<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>isEmpty方法： 判断队列是否空</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> rear == front;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>getQueue方法：获取队列,出队列</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>{</span><br><span class="line">     <span class="comment">//判断队列是否为空</span></span><br><span class="line">     <span class="keyword">if</span>(isEmpty()){</span><br><span class="line">         <span class="comment">//抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">     }</span><br><span class="line">     front++;<span class="comment">//后移</span></span><br><span class="line">     <span class="keyword">return</span> arr[front];</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>showQueue方法：显示队列所有数据</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()){</span><br><span class="line">        System.out.println(<span class="string">"队列空没有数据"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; arr.length;i++) {</span><br><span class="line">        System.out.printf(<span class="string">"arr[%d]=%d\n"</span>,i,arr[i]);</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>headQueue方法： 显示队列头数据</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"队列空没有数据"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>主类ArrayQueueDemo方法： 测试</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">' '</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop){</span><br><span class="line">            System.out.println(<span class="string">"s(show):"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit):"</span>);</span><br><span class="line">            System.out.println(<span class="string">"a(add):"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get):"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head):"</span>);</span><br><span class="line">            key =scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span>(key){</span><br><span class="line">                <span class="keyword">case</span><span class="string">'s'</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">'a'</span>:</span><br><span class="line">                    System.out.print(<span class="string">"请输入一个数："</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span>{</span><br><span class="line">                     <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"取出的数据是%d\n"</span>,res);</span><br><span class="line">                    }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span>{</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"队列头的数据是%d\n"</span>,res);</span><br><span class="line">                    }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">'e'</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"退出"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li><p>addQueue方法：</p>
<p><img src="/2024/08/19/ArrayQueue/01.png"></p></li>
<li><p>showQueue方法：</p>
<p><img src="/2024/08/19/ArrayQueue/02.png"></p></li>
<li><p>headQueue方法：</p>
<p><img src="/2024/08/19/ArrayQueue/03.png"></p></li>
<li><p>getQueue方法：</p>
<p><img src="/2024/08/19/ArrayQueue/04.png"></p></li>
<li><p>exit方法：</p>
<p><img src="/2024/08/19/ArrayQueue/05.png"></p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>四数相加</title>
    <url>/2026/01/19/FourSumII/</url>
    <content><![CDATA[<h1 id="算法-四数相加">算法-四数相加</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法--四数相加</p></li>
<li><p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j,
k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500
。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1
。</p>
<p><strong>例如:</strong></p>
<p>输入:</p>
<ul>
<li>A = [ 1, 2]</li>
<li>B = [-2,-1]</li>
<li>C = [-1, 2]</li>
<li>D = [ 0, 2]</li>
</ul>
<p>输出:</p>
<p>2</p>
<p><strong>解释:</strong></p>
<p>两个元组如下:</p>
<ol type="1">
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 =
0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 =
0</li>
</ol></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>定义一个哈希map，key放a和b俩数之和，value放a和b俩数和出现的次数</li>
<li>遍历A、B数组，统计两数和和出现次数</li>
<li>再遍历C、D数组、找到0-（c+d）在map中出现，count+value（value即出现的次数）</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums2){</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> i + j;</span><br><span class="line">                map.put(sum,map.getOrDefault(sum,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4){</span><br><span class="line">                r += map.getOrDefault(<span class="number">0</span> - i - j,<span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><code>getOrDefault</code> 核心作用：<strong>简化 Map 中 “获取值 +
处理键不存在” 的逻辑</strong>，避免手动判断 <code>containsKey</code>。
<ul>
<li>尝试从 <code>Map</code> 中获取指定 <code>key</code> 对应的
<code>value</code>；</li>
<li>如果 <code>key</code> <strong>存在</strong>，返回对应的
<code>value</code>；</li>
<li>如果 <code>key</code> <strong>不存在</strong>，返回你指定的
<code>defaultValue</code>（默认值）。</li>
</ul></li>
<li>语法规则：<code>map.getOrDefault(键, 默认值)</code>，返回值类型和
“默认值” 类型一致（比如键是 Integer，默认值也得是 Integer）。</li>
<li>典型场景：计数统计（如四数相加的次数统计）、避免空值（NPE）、默认值兜底等。</li>
<li>关键逻辑：利用 <code>a + b + c + d = 0</code> 等价于
<code>a + b = -(c + d)</code>，通过哈希表快速匹配目标值。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>赎金信</title>
    <url>/2026/01/21/RansomNote/</url>
    <content><![CDATA[<h1 id="算法-赎金信">算法-赎金信</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法--赎金信</p></li>
<li><p>博主以<a href="%5B383.%20赎金信%20%7C%20代码随想录%5D(https://programmercarl.com/0383.赎金信.html#思路)">代码随想录</a>算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li><p>给定一个赎金信 (ransom)
字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom
能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true
；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p><strong>注意：</strong></p>
<p>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct("a", "b") -&gt; false canConstruct("aa", "ab") -&gt;
false canConstruct("aa", "aab") -&gt; true</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>暴力枚举：俩层for循环</li>
<li>哈希数组：使用哈希数组，先定义一个哈希数组int[26]，遍历magazine字符串，在对应的下标增1，再遍历ransomNote字符串，在对应的数组下标减1，如果出现负数，表示false</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> {</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length()){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray()){</span><br><span class="line">            record[c - <span class="string">'a'</span>] += <span class="number">1</span>; <span class="comment">//即对应的下标加一</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray()){</span><br><span class="line">            record[c - <span class="string">'a'</span>] -= <span class="number">1</span>;  <span class="comment">//即对应的下标减一</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : record){</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><p>核心思路：<strong>用数组代替哈希表统计字符频次</strong>（仅小写字母场景），先统计
<code>magazine</code> 的字符数，再扣除 <code>ransomNote</code>
所需字符数，最后检查是否有字符不足。</p></li>
<li><p>关键转换：<code>c - 'a'</code>
将字符映射到数组下标，是处理小写字母计数的经典技巧。</p></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希数组</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>替换数字</title>
    <url>/2026/01/25/ReplaceNumbers/</url>
    <content><![CDATA[<h1 id="算法-替换数字">算法-替换数字</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法--替换数字</p></li>
<li><p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li><p>给定一个字符串
s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p>
<p>例如，对于输入字符串 "a1b2c3"，函数应该将其转换为
"anumberbnumbercnumber"。</p>
<p>对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"</p>
<p>输入：一个字符串 s,s 仅包含小写字母和数字字符。</p>
<p>输出：打印一个新的字符串，其中每个数字字符都被替换为了number</p>
<p>样例输入：a1b2c3</p>
<p>样例输出：anumberbnumbercnumber</p>
<p>数据范围：1 &lt;= s.length &lt; 10000。</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><strong>统计数字数量</strong>：
<ul>
<li>先遍历原字符串，统计其中数字字符的个数。这一步的核心目的是计算新字符串的长度
—— 因为每个数字（1 个字符）要替换成 "number"（6
个字符），相当于每个数字会让字符串长度增加 5，因此新长度 = 原长度 +
数字个数 × 5。</li>
</ul></li>
<li><strong>创建新字符数组</strong>：
<ul>
<li>基于计算出的新长度，创建一个固定长度的字符数组</li>
</ul></li>
<li><strong>双指针从后往前填充：</strong>
<ul>
<li>定义两个指针：<code>i</code>指向新字符数组的末尾（待填充位置），<code>j</code>指向原字符串的末尾（待遍历位置）。</li>
<li>从后往前遍历原字符串：
<ul>
<li>如果<code>j</code>指向的是字母，直接将该字母复制到<code>i</code>的位置，然后<code>i</code>和<code>j</code>都向前移动一位；</li>
<li>如果<code>j</code>指向的是数字，从<code>i</code>的位置向前依次填充
'r'、'e'、'b'、'm'、'u'、'n'（即 "number"
的逆序），然后<code>i</code>向前移动 6
位，<code>j</code>向前移动一位。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceNumber</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sOldSize</span> <span class="operator">=</span> s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一步：统计字符串中的数字数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sOldSize; i++) {</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) {</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二步：创建新字符数组，长度 = 原长度 + 数字个数*5（number是6个字符，替换1个数字多占5位）</span></span><br><span class="line">        <span class="type">char</span>[] newS = <span class="keyword">new</span> <span class="title class_">char</span>[sOldSize + count * <span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sNewSize</span> <span class="operator">=</span> newS.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第三步：双指针从后往前填充（核心修正）</span></span><br><span class="line">        <span class="comment">// i：新数组指针，j：原字符串指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">            <span class="comment">// 如果是字母，直接复制到新数组</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(s.charAt(j))) {</span><br><span class="line">                newS[i] = s.charAt(j);</span><br><span class="line">                i--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 如果是数字，替换为"number"（从后往前填）</span></span><br><span class="line">                newS[i] = <span class="string">'r'</span>;</span><br><span class="line">                newS[i - <span class="number">1</span>] = <span class="string">'e'</span>;</span><br><span class="line">                newS[i - <span class="number">2</span>] = <span class="string">'b'</span>;</span><br><span class="line">                newS[i - <span class="number">3</span>] = <span class="string">'m'</span>;</span><br><span class="line">                newS[i - <span class="number">4</span>] = <span class="string">'u'</span>;</span><br><span class="line">                newS[i - <span class="number">5</span>] = <span class="string">'n'</span>;</span><br><span class="line">                i -= <span class="number">6</span>; <span class="comment">// 直接移动6位，避免循环的i--干扰（更清晰）</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newS);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(replaceNumber(s));</span><br><span class="line">        scanner.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>从后往前填充的优势：避免从前往后填充时数字替换导致的字符覆盖，无需频繁移动已处理的字符，时间复杂度为
O (n)（n 为原字符串长度）。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串</title>
    <url>/2026/01/24/ReverseAString/</url>
    <content><![CDATA[<h1 id="算法-反转字符串">算法-反转字符串</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法--反转字符串</p></li>
<li><p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组
char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1)
的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1： 输入：["h","e","l","l","o"] 输出：["o","l","l","e","h"]</p>
<p>示例 2： 输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>采用双指针法</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> {</span><br><span class="line">        <span class="comment">// 左指针：初始指向数组头部</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 右指针：初始指向数组尾部</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 两指针未相遇时循环交换</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">            <span class="comment">// 临时变量存储左指针值，避免覆盖</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> s[l];</span><br><span class="line">            <span class="comment">// 交换左右指针对应的值</span></span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = t;</span><br><span class="line">            <span class="comment">// 左指针右移</span></span><br><span class="line">            l++;</span><br><span class="line">            <span class="comment">// 右指针左移</span></span><br><span class="line">            r--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>还可以使用位运算</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的单词</title>
    <url>/2026/01/26/ReverseTheWordsInAString/</url>
    <content><![CDATA[<h1 id="反转字符串中的单词">反转字符串中的单词</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构--反转字符串中的单词</p></li>
<li><p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="问题">问题</h2>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1： 输入: "the sky is blue" 输出: "blue is sky the"</p>
<p>示例 2： 输入: " hello world! " 输出: "world! hello" 解释:
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3： 输入: "a good example" 输出: "example good a" 解释:
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个</p>
<h2 id="思路">思路</h2>
<ul>
<li><strong>清理多余空格</strong>：去除字符串首尾的空格，同时将单词之间的多个空格缩减为一个。</li>
<li><strong>反转整个字符串</strong>：将清理后的字符串整体反转。</li>
<li><strong>反转每个单词</strong>：遍历反转后的字符串，将每个独立的单词再反转回来，最终得到单词顺序反转的结果。</li>
<li><strong>快慢指针法</strong>：
<ul>
<li><strong>快指针（fast）</strong>：负责遍历原始字符数组，寻找有效字符（非空格）。</li>
<li><strong>慢指针（slow）</strong>：负责在原数组上 “构建”
无多余空格的新数组，记录有效字符的存放位置。</li>
</ul></li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> {</span><br><span class="line">         <span class="comment">// 1. 去除多余空格（首尾空格 + 单词间多余空格）</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        chars = reverseExtraSpaces(chars);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 反转整个字符串</span></span><br><span class="line">        reverse(chars,<span class="number">0</span>,chars.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 反转每个单词</span></span><br><span class="line">        reverseEachWord(chars);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去掉多余空格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] reverseExtraSpaces(<span class="type">char</span>[] chars){</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 慢指针：记录有效字符的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;fast&lt;chars.length;fast++){</span><br><span class="line">             <span class="comment">// 只处理非空格字符（跳过所有空格）</span></span><br><span class="line">            <span class="keyword">if</span>(chars[fast] != <span class="string">' '</span>){ </span><br><span class="line">             <span class="comment">// 如果不是第一个单词，先在单词前加一个空格（避免开头有空格）   </span></span><br><span class="line">                <span class="keyword">if</span>(slow != <span class="number">0</span>){</span><br><span class="line">                    chars[slow++] = <span class="string">' '</span>; </span><br><span class="line">                    }</span><br><span class="line">                 <span class="comment">// 把当前单词的所有字符复制到慢指针位置</span></span><br><span class="line">                 <span class="comment">// 循环条件：fast没越界 且 当前字符不是空格（即还在同一个单词内）</span></span><br><span class="line">                    <span class="keyword">while</span>(fast &lt; chars.length &amp;&amp; chars[fast] != <span class="string">' '</span>)</span><br><span class="line">                       chars[slow++] = chars[fast++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 截取有效长度的字符数组（去掉后面的无效部分）</span></span><br><span class="line">        <span class="type">char</span>[] newChars = <span class="keyword">new</span> <span class="title class_">char</span>[slow];</span><br><span class="line">        System.arraycopy(chars,<span class="number">0</span>,newChars,<span class="number">0</span>,slow);</span><br><span class="line">        <span class="keyword">return</span> newChars;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//反转指定区间的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> left, <span class="type">int</span> right)</span>{</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=chars.length){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">         <span class="comment">// 双指针交换左右字符，向中间靠拢</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//反转每个单词</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(<span class="type">char</span>[] chars)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录每个单词的起始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;end &lt;=chars.length;end++){</span><br><span class="line">            <span class="keyword">if</span>(end == chars.length || chars[end] == <span class="string">' '</span>){</span><br><span class="line">                reverse(chars,start,end-<span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;<span class="comment">// 更新下一个单词的起始位置</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>记住三步走：清理空格、反转整体、反转单词（区间）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串Ⅱ</title>
    <url>/2026/01/24/ReverseAString%E2%85%A1/</url>
    <content><![CDATA[<h1 id="算法-反转字符串ⅱ">算法-反转字符串Ⅱ</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法--反转字符串Ⅱ</p></li>
<li><p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k
个字符，就反转这 2k 个字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k
个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s = "abcdefg", k = 2 输出: "bacdfeg"</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>分段遍历 + 双指针反转</li>
<li><strong>分段逻辑</strong>：将字符串按 2k 长度分段，遍历步长设为
2k（<code>i += 2*k</code>）；</li>
<li><strong>边界处理</strong>：对每一段，计算反转的结束指针 end：
<ul>
<li>若剩余字符 ≥k → end = start + k - 1；</li>
<li>若剩余字符 &lt;k → end = 数组最后一个索引（用 <code>Math.min</code>
统一处理）；</li>
</ul></li>
<li><strong>复用基础反转</strong>：在 [start, end]
区间内，用“双指针+临时变量交换”反转字符；</li>
<li><strong>类型转换</strong>：String 不可变，先转为 char[]
原地修改，最后转回 String。</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 代码</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="comment">// 转为字符数组，支持原地修改</span></span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">// 按2k步长分段遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k){</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 关键：处理剩余字符不足k的边界情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 双指针反转[start, end]区间字符</span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end){</span><br><span class="line">                <span class="comment">// 临时变量交换（新手友好，易理解）</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">                ch[start] = ch[end];</span><br><span class="line">                ch[end] = temp;</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 字符数组转回字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li><strong>核心难点</strong>：end指针的边界计算（<code>Math.min</code>
的使用），解决“剩余字符不足k”的越界问题；</li>
<li><code>Math.min(a, b)</code>取 a 和 b
中的<strong>较小值</strong></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>栈模拟计算器</title>
    <url>/2024/11/05/StackSimulatorCalculator/</url>
    <content><![CDATA[<h1 id="栈模拟计算器">栈模拟计算器</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——栈</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>定义两个栈，一个为数栈numStack，用于存放数，一个为符号栈operStack，用于存放运算符</li>
<li>设置索引index遍历表达式</li>
<li>index指数，则直接入数栈</li>
<li>index扫描为运算符，则分不同情况
<ul>
<li>符号栈为空，直接入栈</li>
<li>符号栈不为空，就进行比较
<ul>
<li>当前运算符的优先级小于或等于栈中的运算符，就从数栈中取出两个数和从符号栈中取出一个符号进行运算，将结果入数栈，再将当前的运算符入符号栈</li>
<li>当前运算符的优先级大于栈中的运算符，直接入符号栈</li>
</ul></li>
</ul></li>
<li>当整个表达式扫描完毕，就可以按顺序pop出数字和符号进行运算了</li>
<li>数栈的最后一个数就是结果</li>
</ul>
<h2 id="实现步骤">实现步骤</h2>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="meta">@SuppressWarnings({""})</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">"8-2*3+1"</span>;</span><br><span class="line">        <span class="comment">//创建两个栈，一个数栈，一个符号栈</span></span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义相关变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">' '</span>;<span class="comment">//将每次扫描得到char保存到ch</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">" "</span>;<span class="comment">//变量，用于拼接多位数</span></span><br><span class="line">        <span class="comment">//开始while扫描expression</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//依次得到expression的每一个字符</span></span><br><span class="line">            ch = expression.substring(index,index+<span class="number">1</span>).charAt(<span class="number">0</span>);<span class="comment">//substring用法</span></span><br><span class="line">            <span class="comment">//判断ch是什么做相应处理</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isOper(ch)){<span class="comment">//如果是运算符</span></span><br><span class="line">                <span class="comment">//判断当前符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty()){</span><br><span class="line">                    <span class="comment">//如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就需要重数栈中取出两数</span></span><br><span class="line">                    <span class="comment">//从符号栈中取出一个符号进行运算，将运算结果入数栈，将当前操作符入符号栈</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch)&lt;= operStack.priority(operStack.peek())){</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1,num2,oper);</span><br><span class="line">                        <span class="comment">//把运算结果入数栈</span></span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//把当前符号入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        <span class="comment">//如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    }</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="comment">//如果为空直接入栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//如果是数直接入数栈</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">//            numStack.push(ch-48);//在表中‘1’是49</span></span><br><span class="line">                <span class="comment">//思路分析</span></span><br><span class="line">                <span class="comment">//1.当处理多位数时，不能发现一个数就入栈</span></span><br><span class="line">                <span class="comment">//2.在处理数时，需要向expression的表达式的index后看一位，如果是数就进行扫描，是符号就入栈</span></span><br><span class="line">                <span class="comment">//3.需要 定义一个变量字符串用于拼接</span></span><br><span class="line">                <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line">                <span class="comment">//如果ch已经是最后一位就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span> (index == expression.length()-<span class="number">1</span>){</span><br><span class="line">                      numStack.push(Integer.parseInt(keepNum.trim()));</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="comment">//判断下个字符是是不是数字，如果是数字就继续扫描，是符号就入栈</span></span><br><span class="line">                    <span class="comment">//注意是看后一位，不是index++</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>))){</span><br><span class="line">                        <span class="comment">//是的话，后面一位是符号，入栈</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum.trim()));</span><br><span class="line">                        <span class="comment">//重要：keepNum清空</span></span><br><span class="line">                        keepNum = <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//让index+1，判断是否扫描到expression最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index&gt;= expression.length()){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">           <span class="comment">// 当表达式扫描完毕，就顺序从数栈和符号栈pop出数进行运算</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算到最后结果</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isEmpty()){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1,num2,oper);</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(expression+<span class="string">"="</span>+numStack.pop());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//先创建一个栈，需要扩展功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack2</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//数组模拟栈，数据放在该数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack2</span><span class="params">(<span class="type">int</span> maxSize)</span> {</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//增加一个方法，可以返回当前栈顶的值,但不是取出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> top == maxSize -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//入栈push</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>{</span><br><span class="line">        <span class="comment">//判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull()){</span><br><span class="line">            System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//出栈pop，将栈顶数据返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">//先判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()){</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"栈空"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//遍历栈，遍历时要从栈顶开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()){</span><br><span class="line">            System.out.println(<span class="string">"栈空没有数据"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//从栈顶开始显示数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            System.out.printf(<span class="string">"stack[%d]==%d\n"</span>,i,stack[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//返回运算符优先级，由程序员确定，用数字表示，数字越大，优先级越高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span>{</span><br><span class="line">        <span class="keyword">if</span> (oper==<span class="string">'*'</span>||oper==<span class="string">'/'</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(oper==<span class="string">'+'</span>||oper==<span class="string">'-'</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假定只有加减乘除</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span>{</span><br><span class="line">        <span class="keyword">return</span> val ==<span class="string">'+'</span>||val==<span class="string">'-'</span>||val==<span class="string">'*'</span>||val==<span class="string">'/'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//res用于存放结果</span></span><br><span class="line">        <span class="keyword">switch</span>(oper){</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                res = num2 - num1;<span class="comment">//注意顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                res = num2 / num1;<span class="comment">//注意顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>四数之和</title>
    <url>/2026/01/23/SumOfFourNumbers/</url>
    <content><![CDATA[<h1 id="算法-四数之和">算法-四数之和</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法--四数之和</p></li>
<li><p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断
nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target
相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。
满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]
]</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>这道题是经典的「N 数之和」问题，核心思路是<strong>排序 +
双指针</strong>，通过降维将四数之和转化为三数之和，再转化为两数之和，同时通过剪枝和去重避免重复结果：
<ul>
<li>排序：对数组排序</li>
<li>俩层循环固定前俩个数</li>
<li>双指针找后俩个数</li>
<li>剪枝优化</li>
<li>去重</li>
</ul></li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="comment">// 结果集初始化</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 边界条件：数组长度小于4，直接返回空结果</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 排序数组（核心前提）</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 第一层循环：固定第一个数 nums[k]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length - <span class="number">3</span>; k++) {</span><br><span class="line">            <span class="comment">// 剪枝1：如果当前数大于target且非负，后续数更大，不可能凑出target，直接终止循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 去重1：跳过和前一个数重复的nums[k]（避免重复四元组）</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 第二层循环：固定第二个数 nums[i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt; nums.length - <span class="number">2</span>; i++) {</span><br><span class="line">                <span class="comment">// 剪枝2：前两个数的和大于target且非负，后续数更大，终止内层循环</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 去重2：跳过和前一个数重复的nums[i]（注意i的起始是k+1，所以去重条件是i &gt; k+1）</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4. 双指针：找后两个数 nums[left] 和 nums[right]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) {</span><br><span class="line">                    <span class="comment">// 用long避免int溢出（关键！比如大数相加会超出int范围）</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right];</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">                        <span class="comment">// 和太大，右指针左移（减小和）</span></span><br><span class="line">                        right--;</span><br><span class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                        <span class="comment">// 和太小，左指针右移（增大和）</span></span><br><span class="line">                        left++;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// 5. 找到符合条件的四元组，加入结果集</span></span><br><span class="line">                        result.add(Arrays.asList(nums[k], nums[i], nums[left], nums[right]));</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 去重3：跳过重复的nums[right]</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) {</span><br><span class="line">                            right--;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 去重4：跳过重复的nums[left]</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) {</span><br><span class="line">                            left++;</span><br><span class="line">                        }</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 6. 双指针同时移动，找下一组可能的数</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>N 数之和问题均可通过「排序 + 双指针」降维解决（三数之和是一层循环 +
双指针，四数之和是两层循环 + 双指针）。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2026/01/22/SumOfThreeNumbers/</url>
    <content><![CDATA[<h1 id="算法-三数之和">算法-三数之和</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法--三数之和</p></li>
<li><p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素
a，b，c ，使得 a + b + c = 0
？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>哈希法：俩层for循环，再用哈希法确定第3个数，但是去重难度大</li>
<li>双指针法：先将数组排序，一层for循环，i重下标为0开始，建立left指针指向i的下一位、rigth指针指向最后一位</li>
<li>nums[i] + nums[left] + nums[right] &gt; 0表示大了，right向左移</li>
<li>nums[i] + nums[left] + nums[right] &lt; 0表示小了，left向右移</li>
<li>nums[i] + nums[left] + nums[right] = 0表示找到符合标准的</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//排序，为去重准备</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> result; <span class="comment">//首位最小但是大于0，表示没有负数，直接返回结果</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]){    <span class="comment">//去重，</span></span><br><span class="line">                <span class="keyword">continue</span>;             </span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;   <span class="comment">//左指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rigth</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;  <span class="comment">//右指针</span></span><br><span class="line">            <span class="keyword">while</span>(rigth &gt; left){       <span class="comment">//没有=，因为要求3位数，等于只剩2位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] +nums[rigth];  </span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>){   <span class="comment">//和大，右指针往左移动</span></span><br><span class="line">                    rigth--;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>){ <span class="comment">//和小，左指针往右移动</span></span><br><span class="line">                    left++;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[left],nums[rigth]));  <span class="comment">//找到符合的结果</span></span><br><span class="line">                    <span class="keyword">while</span>(rigth &gt; left &amp;&amp; nums[rigth] == nums[rigth-<span class="number">1</span>]){    <span class="comment">//去重</span></span><br><span class="line">                        rigth--;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">while</span>(rigth &gt; left &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]){   <span class="comment">//去重</span></span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    rigth--;</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>三数之和的核心逻辑是：排序 + 固定第一个数 +
双指针找后两个数，去重逻辑是避免重复三元组的关键。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>单向环形链表</title>
    <url>/2024/09/17/Unidirectionalcircularlinkedlist/</url>
    <content><![CDATA[<h1 id="单向环形链表">单向环形链表</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——单向链表</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="问题">问题</h2>
<p>Josephu（约瑟夫，约瑟夫环）问题</p>
<p>设编号1，2，3.....n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，它
的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人出列为止。</p>
<h2 id="思路">思路</h2>
<ul>
<li>构建一个单向环形链表的思路
<ul>
<li>先创建第一个节点，让first指向该节点,并形成环形</li>
<li>后面当我们每创建一个新的节点，就把该节点加入到已有的环形链表当中</li>
</ul></li>
<li>遍历环形链表
<ul>
<li>先让一个辅助指针（变量）<strong>curboy</strong>，指向<strong>first</strong>节点</li>
<li>然后通过一个while循环遍历该环形链表</li>
<li><strong>curBoy.next == firs</strong>t遍历结束</li>
</ul></li>
<li>出圈
<ul>
<li><p>先创建一个辅助指针<strong>helper</strong>，先指向环形链表的最后节点</p></li>
<li><p>小孩报数前，先让<strong>first</strong>和<strong>helper</strong>移动k-1次</p></li>
<li></li>
<li><p>这时就可以将<strong>first</strong>指向的小孩节点出圈</p>
<ul>
<li><p><strong>first = first.next</strong></p></li>
<li><p><strong>helper.next= first</strong></p></li>
<li><p>原来的节点没有被引用，就会被回收</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li><p>创建一个Boy类，表示一个节点</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>{</span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//表示指向下个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span>{</span><br><span class="line">        <span class="built_in">this</span>.no=no;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> {</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> {</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>创建一个单向环形链表CircleSingleLinkedList类</p>
<ul>
<li><p>创建一个first节点，当前没有编号</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span>{</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(-<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>添加小孩节点addBoy，构建一个环形链表</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span>{</span><br><span class="line">    <span class="comment">//nums做一个数据校验</span></span><br><span class="line">    <span class="keyword">if</span>(nums&lt;<span class="number">1</span>){</span><br><span class="line">        System.out.println(<span class="string">"nums不正确"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//辅助变量，帮助构建环形链表</span></span><br><span class="line">    <span class="comment">//使用for来创建我们的环形链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=nums;i++){</span><br><span class="line">        <span class="comment">//根据编号，创建小孩节点</span></span><br><span class="line">       <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">       <span class="comment">//如果是第一个小孩</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>){</span><br><span class="line">            first =boy;</span><br><span class="line">            first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">            curBoy = first;<span class="comment">//让curBoy指向第一个小孩</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">              curBoy.setNext(boy);</span><br><span class="line">              boy.setNext(first);</span><br><span class="line">              curBoy = boy;</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>遍历当前环形链表</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span>){</span><br><span class="line">            System.out.println(<span class="string">"没有任何小孩"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="comment">//因为first不能动，所以使用辅助指针</span></span><br><span class="line">    <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            System.out.printf(<span class="string">"小孩的编号%d\n"</span>,curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span>(curBoy.getNext()==first){<span class="comment">//说明遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            curBoy = curBoy.getNext();<span class="comment">//curBoy后移</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>根据用户输入，计算小孩出圈的顺序</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据用户输入，计算小孩出圈的顺序</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo,<span class="type">int</span> countNum,<span class="type">int</span> nums)</span>{</span><br><span class="line">     <span class="comment">//startNo表示从哪个小孩开始数</span></span><br><span class="line">     <span class="comment">//countNum表示数几下</span></span><br><span class="line">     <span class="comment">//nums表示最初有多少小孩在圈中</span></span><br><span class="line">     <span class="keyword">if</span>(first==<span class="literal">null</span>||startNo&lt;<span class="number">1</span>||startNo&gt;nums){</span><br><span class="line">         System.out.println(<span class="string">"参数输入有误，请重新输入"</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//创建辅助指针，帮助小孩出圈</span></span><br><span class="line">     <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">     <span class="comment">//应指向环形链表最后节点</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">         <span class="keyword">if</span>(helper.getNext() == first){</span><br><span class="line">             <span class="comment">//说明helper指向最后小孩节点</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         }</span><br><span class="line">         helper = helper.getNext();</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//小孩报数前，先让first和helper移动k-1次</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j= <span class="number">0</span>;j&lt;startNo-<span class="number">1</span>;j++){</span><br><span class="line">         first = first.getNext();</span><br><span class="line">         helper = helper.getNext();</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//当小孩报数时，让first和helper指针同时移动m-1次,直到圈中只有一个人</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">         <span class="keyword">if</span>(helper == first){<span class="comment">//说明圈中只有一个人</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//让first和helper指针同时移动countNum-1，然后出圈</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">0</span>;j&lt;countNum-<span class="number">1</span>;j++){</span><br><span class="line">             first = first.getNext();</span><br><span class="line">             helper = helper.getNext();</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//这时first指向的节点就是小孩出圈的节点</span></span><br><span class="line">         System.out.printf(<span class="string">"小孩%d出圈\n"</span>,first.getNo());</span><br><span class="line">         <span class="comment">//这时将first指向小孩节点出圈</span></span><br><span class="line">         first = first.getNext();</span><br><span class="line">         helper.setNext(first);</span><br><span class="line">     }</span><br><span class="line">     System.out.printf(<span class="string">"最后留在圈中的小孩编号%d\n"</span>,first.getNo());</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数组环形队列</title>
    <url>/2024/08/19/arrayCircularQueue/</url>
    <content><![CDATA[<h1 id="数组环形队列">数组环形队列</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——数组环形队列</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>对数据环形队列进行优化，解决普通数组队列不能重复使用数组的问题</li>
<li>通过取模来实现</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>调整front变量：将<strong>front指向队列的第一个元素</strong>，front赋初值为0</li>
<li>调整rear变量：
将<strong>rear指向队列的倒数第二个位置的元素</strong>，空出来的空间位置作为约定，rear赋初值为0</li>
<li>当队列满时，<strong>（rear + 1）% maxSize =
front</strong>//算法</li>
<li>当队列空时，<strong>rear==front</strong></li>
<li>队列中有效的数据的个数（<strong>rear+maxSize-front）%maxSize</strong>//算法</li>
</ul>
<h2 id="修改arrayqueue类实现">修改ArrayQueue类实现</h2>
<ul>
<li><p>修改ArrayQueue类</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleArray</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//队列头,指向队列第一元素，赋0值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾，指向队列倒数第二个元素，赋0值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//存储队列的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleArray</span><span class="params">(<span class="type">int</span> arrMaxSize)</span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改isFull（）方法判断队列是否为满</p>
<ul>
<li><p>当队列满时，<strong>（rear + 1）% maxSize =
front</strong>//算法</p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize == front;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改isEmpty（）方法判断队列是否空</p>
<ul>
<li><p>当队列空时，<strong>rear==front</strong></p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> rear == front;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改addQueue（）方法添加数据</p>
<ul>
<li><p>先判断队列是否满，再添加数据进入队列</p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">      <span class="comment">//判断队列是否满</span></span><br><span class="line">      <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;队列满了，不能再添加数据&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//直接将数据加入</span></span><br><span class="line">      arr[rear] = n;</span><br><span class="line">      <span class="comment">//将rear后移，考虑取模</span></span><br><span class="line">      rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改getQueue（）方法获取队列，出队列</p>
<ul>
<li><p>先判断队列是否空，若有数据，则将数据出队列</p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取队列,出队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//front是指向队列的第一个元素</span></span><br><span class="line">    <span class="comment">// 1.将front对应的值保留到一个临时变量</span></span><br><span class="line">    <span class="comment">// 2.将front 后移</span></span><br><span class="line">    <span class="comment">// 3.将临时保存的变量返回</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arr[front];</span><br><span class="line">    front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改showQueue（）方法显示队列所有数据</p>
<ul>
<li><p>先判断队列是否为空，若存在数据就显示数据</p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示队列所有数据</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;队列空没有数据&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//思路：从front开始遍历，遍历的多少个元素</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; front+size();i++) &#123;<span class="comment">//取模</span></span><br><span class="line">         System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i%maxSize,arr[i%maxSize]);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求出当前队列有效数据的个数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (rear+maxSize-front)%maxSize;<span class="comment">//取模</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改headQueue（）方法显示队列头数据</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示队列头数据</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空没有数据&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr[front];<span class="comment">//ArrayQueue中是front+1</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>CircleArrayDemo类测试</p>
<ul>
<li><p>代码实现与ArrayQueueDemo类大体相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试环形数据队列&quot;</span>);</span><br><span class="line">        <span class="type">CircleArray</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArray</span>(<span class="number">3</span>);  <span class="comment">//修改为环形队列</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):&quot;</span>);</span><br><span class="line">            key =scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>,res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>,res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li><p>addQueue（）方法</p>
<p><img src="/2024/08/19/arrayCircularQueue/a.png"></p></li>
<li><p>getQueue（）方法</p>
<p><img src="/2024/08/19/arrayCircularQueue/g.png"></p></li>
<li><p>showQueue（）方法</p>
<p><img src="/2024/08/19/arrayCircularQueue/s.png"></p></li>
<li><p>headQueue（）方法</p>
<p><img src="/2024/08/19/arrayCircularQueue/h.png"></p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2024/10/09/bubbleSort/</url>
    <content><![CDATA[<h1 id="冒泡排序">冒泡排序</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法——冒泡排序</p>
<span id="more"></span></li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>冒泡排序是最简单的交换排序，通过俩俩比较进行交换</li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><p>用两层for循环解决</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">bubbleSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> arr[]={<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">99</span>,<span class="number">44</span>,<span class="number">66</span>,<span class="number">1</span>};</span><br><span class="line">        <span class="type">int</span> temp;<span class="comment">//辅助变量，交换值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//优化，判断是否发生排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) {<span class="comment">//比较轮数，-1是指不与自身排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-i; j++) {<span class="comment">//每一轮比较次数</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>]){<span class="comment">//大于小于号表示按照升序排序还是降序排序</span></span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++){</span><br><span class="line">         System.out.println(arr[i]);</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录</title>
    <url>/2024/01/27/bwl/</url>
    <content><![CDATA[<h1 id="备忘录">备忘录</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>记录一些容易忘记的内容</p></li>
<li><p>如：函数、启动命令等</p>
<span id="more"></span></li>
</ul>
<h3 id="常用函数">常用函数</h3>
<ul>
<li><p><code>substring(startIndex, endIndex)</code> 的规则是：截取从
<code>startIndex</code>（包含）到
<code>endIndex</code>（不包含）的子串。</p></li>
<li><p><code>resultMap="BaseResultMap"</code>
是MyBatis中非常重要的一个配置，用来<strong>定义Java对象属性与数据库字段的映射关系</strong>。</p></li>
<li><p><code>::</code> 是 <strong>PostgreSQL
的类型转换运算符</strong>，它用来将一个值从一种数据类型转换为另一种数据类型。</p>
<ul>
<li>```java <select id="selectAll" resultmap="BaseResultMap"> SELECT id,
name, description, system_prompt, model, allowed_tools::text AS
allowed_tools, allowed_kbs::text AS allowed_kbs, chat_options::text AS
chat_options, created_at, updated_at FROM agent ORDER BY created_at DESC
</select> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* Spring 的`Assert`工具类，用于参数合法性校验；</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Assert.notNull(agent, "Agent cannot be null");</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>PATCH：只传递需要修改的字段，未传递的字段保持原有值；</p></li>
<li><p>return doubleStr.substring(1, doubleStr.length() -
1).contains(s);</p></li>
<li><p>// 1. doubleStr = s + s （拼接两个原字符串）</p></li>
<li><p>// 2. substring(1, doubleStr.length() -
1)：截取字符串，去掉首尾各1个字符</p></li>
<li><p>// 3. contains(s)：判断截取后的字符串是否包含原字符串s</p></li>
</ul>
]]></content>
      <categories>
        <category>札记</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>双向链表</title>
    <url>/2024/09/08/doubleLinkedList/</url>
    <content><![CDATA[<h1 id="双向链表">双向链表</h1>
<h2 id="双向链表的增删查改">双向链表的增删查改</h2>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——双向链表</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li><p>双向链表遍历方法与单向链表相同，不过双向链表可以向前和向后查找</p></li>
<li><p>添加，默认添加到最后</p>
<ul>
<li>先找到双向链表的最后节点</li>
<li><strong>temp.next = newHeroNode</strong></li>
<li><strong>newHeroNode.pre = temp</strong></li>
</ul></li>
<li><p>修改，与单链表相同</p></li>
<li><p>删除</p>
<ul>
<li>双向链表可以自我删除</li>
<li>直接找到要删除的节点temp</li>
<li><strong>temp.pre.next = temp.next</strong></li>
<li><strong>temp.next.pre = temp.pre</strong></li>
</ul></li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>使用双向链表实现--水浒传排行榜管理</li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li>与单链表类似</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<ul>
<li><p>修改单链表中HeroNode类</p>
<ul>
<li><p>增加pre变量指向链表中上一个节点</p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next;<span class="comment">//指向下个节点，默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre;<span class="comment">//指向上个节点，默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode2</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> {</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode{"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", nickname='"</span> + nickname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>遍历</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历双向链表，与单链表一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//因为头节点不能动，所以需要辅助变量遍历</span></span><br><span class="line">    <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">//判断链表是否最后</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//输出节点的信息</span></span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="comment">//将节点后移</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>添加</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode2 heroNode)</span> {</span><br><span class="line">    <span class="comment">//当不考虑编号顺序时</span></span><br><span class="line">    <span class="comment">//先找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//将最后节点next指向新的节点</span></span><br><span class="line">    <span class="comment">//因为head头节点不能动，所以需要辅助遍历temp</span></span><br><span class="line">    <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//遍历链表找到最后</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">//代表找到链表的最后</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//找不到就将temp后移，直至找到退出循环</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//当退出循环时，temp指向链表的最后</span></span><br><span class="line">    <span class="comment">//形成双向链表</span></span><br><span class="line">    temp.next = heroNode;</span><br><span class="line">    heroNode.pre = temp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改双向链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upadate</span><span class="params">(HeroNode2 newHeroNode)</span> {</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">    <span class="comment">//定义一个辅助变量temp</span></span><br><span class="line">    <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//已经遍历完链表了</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (temp.no == newHeroNode.no) {</span><br><span class="line">            flag = <span class="literal">true</span>;<span class="comment">//找到</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据flag判断是否找到要修改的节点</span></span><br><span class="line">    <span class="keyword">if</span> (flag) {</span><br><span class="line">        temp.name = newHeroNode.name;</span><br><span class="line">        temp.nickname = newHeroNode.nickname;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>删除</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从双向链表删除节点</span></span><br><span class="line"><span class="comment">//双向链表可以自我删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>{</span><br><span class="line">    <span class="comment">//判断当前链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span>){{</span><br><span class="line">        System.out.println(<span class="string">"链表为空，不能删除"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;<span class="comment">//辅助变量直接指向要删除的节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//判断是否找到要删除节点的标志</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//到了链表最后</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(temp.no == no){<span class="comment">//找到要删除的节点</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        temp = temp.next;<span class="comment">//后移</span></span><br><span class="line">    }<span class="keyword">if</span>(flag){<span class="comment">//找到执行</span></span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) {</span><br><span class="line">                temp.next.pre = temp.pre;<span class="comment">//存在风险，如果是最后一个节点，不需要执行这段代码，否则会出现空指针异常</span></span><br><span class="line">            }</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{<span class="comment">//没有找到执行</span></span><br><span class="line">            System.out.printf(<span class="string">"要删除的节点%d不存在\n"</span>,no);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表模拟栈</title>
    <url>/2024/10/08/linkdist-stack/</url>
    <content><![CDATA[<h1 id="链表模拟栈">链表模拟栈</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——链表模拟栈</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><p>定义一个<strong>HeroNode</strong>类，每一个<strong>HeroNode</strong>对象就是一个节点</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，重写toString方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode{"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", value="</span> + value +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>链表模拟栈<strong>Linkdist_stack</strong>类</p>
<ul>
<li><p>初始化一个头节点<strong>head</strong>，不存放数据</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(-<span class="number">1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>top</strong>为栈顶指针，初始化为<strong>-1</strong></p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span>-<span class="number">1</span>;<span class="comment">//栈顶指针</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>maxLength</strong>为栈的最大容量</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxLength;<span class="comment">//定义最大长度</span></span><br><span class="line"><span class="comment">//设置栈最大容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Linkdist_stack</span><span class="params">(<span class="type">int</span> maxLength)</span> {</span><br><span class="line">    <span class="built_in">this</span>.maxLength = maxLength;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>判断栈是否为空<strong>isEmpty</strong></p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>{</span><br><span class="line">   <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>判断栈是否满<strong>isFull</strong></p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> top&gt;=maxLength-<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>使用倒插法入栈<strong>push</strong></p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>{<span class="comment">//为新节点传入新值</span></span><br><span class="line"></span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">heroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(top,value);</span><br><span class="line">     <span class="keyword">if</span> (isFull()){</span><br><span class="line">         System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     }</span><br><span class="line">     top++;</span><br><span class="line">     <span class="keyword">if</span>(head.next==<span class="literal">null</span>){<span class="comment">//说明没有新节点，可以直接添加</span></span><br><span class="line">         head.next = heroNode;</span><br><span class="line">     }<span class="keyword">else</span>{</span><br><span class="line">         heroNode.next = head.next;</span><br><span class="line">         head.next = heroNode;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>出栈<strong>pop</strong></p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"栈空，没有数据"</span>);</span><br><span class="line">    }</span><br><span class="line">   <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">    head.next = head.next.next;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>显示<strong>show</strong></p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()){</span><br><span class="line">        System.out.println(<span class="string">"栈空没有数据"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="keyword">if</span> (temp.next==<span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>测试类 <strong>linkdist_stackDemo</strong></p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">linkdist_stackDemo</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//测试一下LinkedListStack是否正确</span></span><br><span class="line">        <span class="comment">//先创建一个LinkedListStack对象表示栈</span></span><br><span class="line">        <span class="type">Linkdist_stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Linkdist_stack</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"show:表示显示栈"</span>);</span><br><span class="line">        System.out.println(<span class="string">"exit:表示退出程序"</span>);</span><br><span class="line">        System.out.println(<span class="string">"push:表示添加数据到栈"</span>);</span><br><span class="line">        System.out.println(<span class="string">"pop:表示从栈中取出数据"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop) {</span><br><span class="line">            System.out.print(<span class="string">"\n请输入你的选择:"</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">                    stack.show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">                    System.out.print(<span class="string">"请输入一个数:"</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                        System.out.println(<span class="string">"出栈的数据是："</span> + res);</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="本章重点">本章重点</h2>
<ul>
<li><p>单链表的倒插法的算法</p>
<ul>
<li><p>图解倒插法</p></li>
<li><p>算法：</p>
<ul>
<li><strong>heroNode.next = head.next;</strong> <strong>head.next =
heroNode;</strong></li>
</ul>
<p><img src="/2024/10/08/linkdist-stack/seeya-ch.github.io\source_posts\linkdist-stack\倒插法示意图.png"></p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>小技巧</title>
    <url>/2024/07/31/paper/</url>
    <content><![CDATA[<h1 id="小技巧">小技巧</h1>
<span id="more"></span>
<p>截断文章，让首页不显示所有文章</p>
<p>哈哈哈哈</p>
]]></content>
      <categories>
        <category>札记</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2024/09/08/singLinkedList-02/</url>
    <content><![CDATA[<h1 id="单链表其三">单链表（其三）</h1>
<h2 id="单向链表的练习">单向链表的练习</h2>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——单向链表</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="问题一">问题（一）</h2>
<ul>
<li>获得单链表的节点的个数，不需要统计头节点</li>
</ul>
<h2 id="解决步骤">解决步骤</h2>
<ul>
<li><p>判断链表是否为空，是的话返回0</p></li>
<li><p>设置辅助变量cur指向<strong>head.next</strong></p></li>
<li><p>设置<strong>length</strong>计算节点个数</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得单链表的节点的个数，不需要统计头节点</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span>{</span><br><span class="line">       <span class="keyword">if</span>(head.next == <span class="literal">null</span>){<span class="comment">//判断是否为空列表，是的话返回0</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;<span class="comment">//辅助变量cur</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//计算节点个数</span></span><br><span class="line">       <span class="keyword">while</span>(cur != <span class="literal">null</span>){<span class="comment">//若cur等于null，则代表到达单链表尾部</span></span><br><span class="line">           length++;</span><br><span class="line">           cur=cur.next;<span class="comment">//遍历</span></span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> length;</span><br><span class="line">   }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="问题二">问题（二）</h2>
<ul>
<li>查找单链表中倒数第k个节点</li>
</ul>
<h2 id="解决步骤-1">解决步骤</h2>
<ul>
<li><p>编写一个方法，接收<strong>head节点</strong>，同时接收一个<strong>index</strong></p></li>
<li><p><strong>index表示是倒数地index个节点</strong></p></li>
<li><p>先把链表从头遍历到尾，得到链表的总长度</p></li>
<li><p>得到<strong>size</strong>后，我们从链表的第一个开始遍历（<strong>size-index</strong>）个，就可以得到</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找单链表中倒数第k个节点</span></span><br><span class="line"> <span class="comment">//1.编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"> <span class="comment">//2.index表示是倒数地index个节点</span></span><br><span class="line"> <span class="comment">//3.先把链表从头遍历到尾，得到链表的总长度</span></span><br><span class="line"> <span class="comment">//4.得到size后，我们从链表的第一个开始遍历（size-index）个，就可以得到</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head,<span class="type">int</span> index)</span>{</span><br><span class="line">     <span class="keyword">if</span>(head.next == <span class="literal">null</span> ){<span class="comment">//判断链表是否为空</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);<span class="comment">//调用getLength方法得到链表长度</span></span><br><span class="line">     <span class="keyword">if</span>(index&lt;=<span class="number">0</span>||index&gt;size){  <span class="comment">//如果要查找的数小于0或者大于链表长度，则返回空</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size-index;i++){</span><br><span class="line">         cur = cur.next;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> cur;</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="问题三">问题（三）</h2>
<ul>
<li>将单链表反转</li>
</ul>
<h2 id="解决步骤-2">解决步骤</h2>
<ul>
<li><p>先定义一个新节点<strong>reverseHead = new
HeroNode</strong></p></li>
<li><p>从头到尾遍历原来的链表，每遍历一个节点就将它取出，放在新链表的最前端</p></li>
<li><p>从原来的链表的<strong>head.next=reverseHead.next</strong></p></li>
<li><p><strong>head节点</strong></p>
<ul>
<li>不存放具体数据</li>
<li>作用就是表示单链表头的next</li>
</ul></li>
<li><p><strong>reversHead节点</strong></p>
<ul>
<li>不存放具体数据</li>
<li>作用就是表示单链表头的next</li>
</ul></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表的反转</span></span><br><span class="line"><span class="comment">//1.先定义一个新节点reverseHead = new HeroNode</span></span><br><span class="line"><span class="comment">//2.从头到尾遍历原来的链表，每遍历一个节点就将它取出，放在新链表的最前端</span></span><br><span class="line"><span class="comment">//3.从原来的链表的head.next=reverseHead.next</span></span><br><span class="line"><span class="comment">//head节点</span></span><br><span class="line"><span class="comment">//1.不存放具体数据</span></span><br><span class="line"><span class="comment">//2.作用就是表示单链表头的next</span></span><br><span class="line"><span class="comment">//reversHead节点</span></span><br><span class="line"><span class="comment">//1.不存放具体数据</span></span><br><span class="line"><span class="comment">//2.作用就是表示单链表头的next</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversetList</span><span class="params">(HeroNode head)</span>{</span><br><span class="line">    <span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span>||head.next.next == <span class="literal">null</span>){</span><br><span class="line">        System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//定义辅助变量，遍历原链表</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//指向当前节点cur的下节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//遍历原链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>){</span><br><span class="line">        next = cur.next;<span class="comment">//先保存当前节点的下一节点</span></span><br><span class="line">        cur.next = reverseHead.next;<span class="comment">//将cur的下一节点指向新的链表的最前端</span></span><br><span class="line">        reverseHead.next = cur;<span class="comment">//将cur加到新的链表上</span></span><br><span class="line">        cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//将head.next指向reverHead.next,实现单链表的反转</span></span><br><span class="line">    head.next = reverseHead.next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="问题四">问题（四）</h2>
<ul>
<li>从尾到头打印单链表</li>
</ul>
<h2 id="解决步骤-3">解决步骤</h2>
<ul>
<li><p>方法一：逆序打印单链表，这样的问题：会破坏当前链表，不建议</p></li>
<li><p>方法二：可以利用栈这个数据结构，将各个节点压入栈中，利用栈的先进后出的特点，实现逆序打印</p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从尾到头打印单链表</span></span><br><span class="line">  <span class="comment">//思路：1.逆序打印单链表，这样的问题：会破坏当前链表，不建议</span></span><br><span class="line">  <span class="comment">//     2.可以利用栈这个数据结构，将各个节点压入栈中，利用栈的先进后出的特点，实现逆序打印</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span>{</span><br><span class="line">     <span class="comment">//如果当前链表为空</span></span><br><span class="line">     <span class="keyword">if</span>(head.next == <span class="literal">null</span>){</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     }</span><br><span class="line">     Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">//创建一个栈，将各个节点压入栈中</span></span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">     <span class="keyword">while</span>(cur!=<span class="literal">null</span>){</span><br><span class="line">         stack.push(cur);</span><br><span class="line">         cur= cur.next;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>){</span><br><span class="line">         System.out.println(stack.pop());<span class="comment">//出栈打印，栈的特点是先进后出</span></span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2024/09/04/singleLinkedList-01/</url>
    <content><![CDATA[<h1 id="单链表其二">单链表（其二）</h1>
<h2 id="单向链表的修改和删除">单向链表的修改和删除</h2>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——单向链表</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li><p>使用带head头的单向链表实现--水浒传排行榜管理</p></li>
<li><p>完成单链表的修改和删除</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>修改：
<ul>
<li>修改节点信息，根据编号来修改，即<strong>no（编号）</strong>不能改，根据<strong>newHeroNode的no（编号）</strong>来修改即可</li>
<li>判断链表是否为空</li>
<li>找到需要修改的节点的编号<strong>no</strong></li>
<li>定义一个辅助变量<strong>temp</strong>，设置<strong>flag</strong>变量判断是否找到该节点</li>
</ul></li>
<li>删除
<ul>
<li>先找到需要删除的节点的前一个节点<strong>temp</strong></li>
<li><strong>temp.next = temp.next.next</strong></li>
<li>被删除的节点，不会被其它引用，会直接被回收</li>
</ul></li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li><p>修改</p>
<ul>
<li><p>先判断链表是否为空</p></li>
<li><p>根据<strong>no</strong>编号，找到需要修改的节点</p></li>
<li><p>定义一个辅助变量<strong>temp</strong>和<strong>flag</strong>变量</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upadate</span><span class="params">(HeroNode newHeroNode)</span> {</span><br><span class="line">       <span class="comment">//判断链表是否为空</span></span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) {</span><br><span class="line">           System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">       <span class="comment">//定义一个辅助变量temp</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">           <span class="keyword">if</span> (temp == <span class="literal">null</span>) {</span><br><span class="line">               <span class="keyword">break</span>;<span class="comment">//已经遍历完链表了</span></span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (temp.no == newHeroNode.no) {</span><br><span class="line">               flag = <span class="literal">true</span>;<span class="comment">//找到</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           }</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       }</span><br><span class="line">     <span class="comment">// 根据flag判断是否找到要修改的节点</span></span><br><span class="line">       <span class="keyword">if</span> (flag) {</span><br><span class="line">           temp.name = newHeroNode.name;</span><br><span class="line">           temp.nickname = newHeroNode.nickname;</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="comment">//没有找到</span></span><br><span class="line">           System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>删除</p>
<ul>
<li><p><strong>head</strong>不能动，需要辅助变量<strong>temp</strong>节点找到删除节点的前一节点</p></li>
<li><p>比较时是<strong>temp.next.no</strong>和删除节点的<strong>no</strong>比较</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表</span></span><br><span class="line">    <span class="comment">//head不能动，需要辅助变量temp节点找到删除节点的前一个节点</span></span><br><span class="line"><span class="comment">//    比较时，是temp.next.no和删除节点的no比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>{</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//代表是否找到要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="literal">null</span>){<span class="comment">//已经到了链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==no){</span><br><span class="line">             <span class="comment">//找到删除节点的前节点</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        } <span class="keyword">if</span>(flag){</span><br><span class="line">            <span class="comment">//可以删除</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li><p>修改</p>
<p><img src="/2024/09/04/singleLinkedList-01/修改.png"></p></li>
<li><p>删除</p>
<p><img src="/2024/09/04/singleLinkedList-01/删除.png"></p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏数组</title>
    <url>/2024/08/13/sparseArray/</url>
    <content><![CDATA[<h1 id="稀疏数组">稀疏数组</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——稀疏数组</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>稀疏数组是一种用于存储和处理多维数组中大部分元素为0（或者同一个值）的数据结构。</li>
<li>稀疏数组的处理方法:
<ul>
<li>记录数组一共有几行几列，有几个不同的值。</li>
<li>把不同值的元素的行、列和值分别存入稀疏数组中。</li>
</ul></li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>将原始二维数组转化为稀疏数组
<ul>
<li>原始二维数组（11*11）</li>
<li>稀疏数组（3*3）</li>
</ul></li>
</ul>
<p><span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -16.403ex;" xmlns="http://www.w3.org/2000/svg" width="35.068ex" height="33.937ex" role="img" focusable="false" viewbox="0 -7750 15500 15000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtable"><g data-mml-node="mtr" transform="translate(0,7000)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,5600)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,4200)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,2800)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,1400)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,0)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-1400)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-2800)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-4200)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-5600)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-7000)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(7500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(9000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(10500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(12000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(13500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(15000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></g></g></svg></mjx-container></span></p>
<table>
<thead>
<tr>
<th>行</th>
<th>列</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td>11</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
</tbody>
</table>
<h2 id="步骤">步骤</h2>
<ol type="1">
<li><p>先创建一个11*11的二维数组，0：表示没有棋子，1：表示黑子，2：表示白子</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始棋盘</span></span><br><span class="line">        System.out.println(<span class="string">"原始棋盘"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : chessArr1){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> date : row){</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,date);</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line">        }</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>将二维数据转为稀疏数组</p>
<ul>
<li><p>2.1.先遍历二维数组，得到非0个数。</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) {</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) {</span><br><span class="line">             <span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>){</span><br><span class="line">                 sum++;</span><br><span class="line">             }</span><br><span class="line">         }</span><br><span class="line">     }</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>2.2.创建稀疏数组，给稀疏数组赋值</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span> [sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>2.3.遍历二维数组，将其中非0数赋给稀疏数组</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录第几个非0数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) {</span><br><span class="line">        <span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>){</span><br><span class="line">            count++;</span><br><span class="line">            sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">            sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">            sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul></li>
<li><p>2.4.输出稀疏数组</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"得到的稀疏数组"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) {</span><br><span class="line">           System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">       }</span><br><span class="line">       System.out.println();</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>将稀疏数组恢复成二维数组</p>
<ul>
<li><p>3.1.先读取稀疏数组第一行，创建原始的二维数组</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>3.2.再读取稀疏数组后几行，赋给原始的二维数组</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt; sparseArr.length ; i++) {<span class="comment">//因为第一行是用来创建原始二维数组,所以从第二行开始</span></span><br><span class="line">    chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">2</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>3.3.恢复后的棋盘</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span>[] row : chessArr1){</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> date : row){</span><br><span class="line">        System.out.printf(<span class="string">"%d\t"</span>,date);</span><br><span class="line">    }</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ol>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li>原始棋盘图
<ul>
<li><img src="/2024/08/13/sparseArray/0.1.png"></li>
</ul></li>
<li>稀疏数组图
<ul>
<li><img src="/2024/08/13/sparseArray/0.3.png" style="zoom:150%;"></li>
</ul></li>
<li>恢复棋盘图
<ul>
<li><img src="/2024/08/13/sparseArray/0.2.png"></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2024/09/03/singleLinkedList/</url>
    <content><![CDATA[<h1 id="单链表其一">单链表（其一）</h1>
<h2 id="单向链表的创建和添加">单向链表的创建和添加</h2>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——单向链表</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="概念">概念</h2>
<ul>
<li>链表：
<ul>
<li>链表以节点的方式进行存储</li>
<li>每个节点包含<strong>data域</strong>和<strong>next域</strong>
<ul>
<li><strong>next域指向下一节点</strong></li>
</ul></li>
<li>链表的各个节点不一点按顺序存储</li>
<li>链表分带头节点和没有带头节点的链表</li>
</ul></li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>使用带head头的单向链表实现--水浒传排行榜管理
<ul>
<li>完成对人物的增删改查</li>
<li>第一种方法在添加人物时，直接添加到链表的尾部</li>
<li>第二种方法在添加人物时，根据排名将人物插入到指点位置（如果有这个排名则添加失败，并给出提示）</li>
</ul></li>
</ul>
<h2 id="思路分析">思路分析</h2>
<ul>
<li><p>相关数据</p>
<ul>
<li><strong>int no，String name，String nickName ，HeroNode
next</strong></li>
<li><strong>head节点</strong>
<ul>
<li>不存放具体的数据</li>
<li>作用就是表示单链表头</li>
<li><strong>next</strong>--指向下个节点</li>
</ul></li>
<li><strong>HeroNode节点</strong>
<ul>
<li>数据</li>
<li>next域</li>
</ul></li>
</ul></li>
<li><p>不需要按照编号顺序添加（创建）</p>
<ul>
<li>先创建一个<strong>head头节点</strong>，作用就是表示单链表的头</li>
<li>后面我们添加每一个节点，就直接加入到链表的最后</li>
</ul></li>
<li><p>遍历</p>
<ul>
<li>通过一个辅助遍历，帮助遍历整个链表</li>
</ul></li>
<li><p>需要按照编号顺序添加</p>
<ul>
<li><p>首先找到新添加节点的位置，通过<strong>辅助变量(temp)</strong>找到</p></li>
<li><p><strong>新的节点. next = temp.next</strong></p></li>
<li><p><strong>将temp.next = 新的节点</strong></p></li>
</ul></li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li><p>定义一个HeroNode类，每个HeroNode对象就是一个节点</p>
<ul>
<li><p>相关属性</p>
<ul>
<li>int no，String name，String nickname HeroNode next；</li>
</ul></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> {</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//为了显示方便，重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode{"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", nickname='"</span> + nickname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>定义一个SingleLinkedList类------管理我们的人物</p></li>
<li><p>第一种方法，直接添加数据到尾部</p>
<ul>
<li><p>先初始化一个头节点，头节点不能动，不能存放数据</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>当不考虑编号顺序时，先找到当前链表的最后节点，将最后节点next指向新的节点，因为head头节点不能动，所以需要辅助便利temp遍历</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span>{</span><br><span class="line">        <span class="comment">//当不考虑编号顺序时</span></span><br><span class="line">        <span class="comment">//先找到当前链表的最后节点</span></span><br><span class="line">        <span class="comment">//将最后节点next指向新的节点</span></span><br><span class="line">        <span class="comment">//因为head头节点不能动，所以需要辅助遍历temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表找到最后</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//代表找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="literal">null</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//找不到就将temp后移，直至找到后退出循环</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//当退出循环时，temp指向链表的最后</span></span><br><span class="line">        <span class="comment">//将这个节点的next指向新节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>第二种方法，按照顺序添加人物插入链表</p>
<ul>
<li><p>先初始化一个头节点，头节点不能动，不能存放数据</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>头节点不能动，所以我们需要一个辅助变量temp来寻找添加的位置，因为是单链表，我们找的temp是位于添加位置的前一个节点，否则插入不了</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span>{</span><br><span class="line">        <span class="comment">//头节点不能动，所以我们需要一个辅助变量来寻找添加的位置</span></span><br><span class="line">        <span class="comment">//因为是单链表，我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//flag标志添加的符号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="literal">null</span>){<span class="comment">//表示已经找到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt; heroNode.no){<span class="comment">//位置找到，就是temp的后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no ==heroNode.no){<span class="comment">//编号存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            temp = temp.next;<span class="comment">//后移，遍历当前的链表</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">            <span class="keyword">if</span>(flag){<span class="comment">//不能添加，编号存在</span></span><br><span class="line">        System.out.println(<span class="string">"存在"</span>+heroNode.no);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//插入链表中，temp的后面</span></span><br><span class="line">        heroNode.next = temp.next;</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>显示链表List方法</p>
<ul>
<li><p>先判断链表是否为空，同时需要辅助变量</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">//显示链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>){</span><br><span class="line">        System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//因为头节点不能动，所以需要辅助变量遍历</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">        <span class="comment">//判断链表是否最后</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//输出节点的信息</span></span><br><span class="line">        System.out.println(temp);</span><br><span class="line">      <span class="comment">//将节点后移</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>主类SingLinkedListDemo：测试</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingLinkedListDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">"宋江"</span>,<span class="string">"及时雨"</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">"卢俊义"</span>,<span class="string">"玉麒麟"</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">"吴用"</span>,<span class="string">"智多星"</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">"林冲"</span>,<span class="string">"豹子头"</span>);</span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        <span class="comment">//第一种方法加入</span></span><br><span class="line">       <span class="comment">/* singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(heroNode4);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(heroNode2);*/</span></span><br><span class="line">        <span class="comment">//第二种方法加入，按照顺序加入</span></span><br><span class="line">        System.out.println(<span class="string">"==================================="</span>);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="运行结果图">运行结果图</h2>
<ul>
<li><p>第一种方法</p>
<p><img src="/2024/09/03/singleLinkedList/01.png"></p></li>
<li><p>第二种方法</p>
<p><img src="/2024/09/03/singleLinkedList/02.png"></p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2026/01/19/sumOfTwoNumbers/</url>
    <content><![CDATA[<h1 id="算法-两数之和">算法-两数之和</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>算法--两数之和</p></li>
<li><p>博主以代码随想录算法公开课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="题目">题目</h2>
<ul>
<li><p>给定一个整数数组 nums 和一个目标值
target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li>使用哈希法的时候：当我们需要查询一个元素是否在集合里的时候</li>
<li>本题需要一个集合来存放我们遍历后的元素，在遍历数组的时候再询问这个集合，看元素是否遍历过</li>
<li>map是一种key value的存储结构，key = 数值，value = 下标</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">         <span class="type">int</span>[] r = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];<span class="comment">//储存两个下标</span></span><br><span class="line">         <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">         }</span><br><span class="line">         Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++){</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> target - nums[i]; <span class="comment">//通过相减得出另一个数是什么</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(t)){ <span class="comment">// 关键判断：HashMap中是否存在补数t（说明之前遍历过这个数）</span></span><br><span class="line">                    r[<span class="number">1</span>] = i;</span><br><span class="line">                    r[<span class="number">0</span>] = map.get(t);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                map.put(nums[i],i);  <span class="comment">// 若补数不存在，把当前元素的“数值-下标”存入HashMap，供后续元素查询</span></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ul>
<li>为什么会想到用哈希表
<ul>
<li>当我们需要查询一个元素是否在集合里的时候</li>
</ul></li>
<li>哈希表为什么用map
<ul>
<li>Set 只能存
“值”，只能判断补数是否存在；而我们需要同时获取补数的下标，Map 的
“键值对” 结构刚好能满足 “存数值 + 存下标” 的需求。</li>
</ul></li>
<li>本题map是用来存什么的
<ul>
<li>存已遍历过的数组元素及其下标，相当于
“遍历账本”，供后续元素快速查补数</li>
</ul></li>
<li>map中的key和value用来存什么的
<ul>
<li>key：数值</li>
<li>value：数组下标</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2024/10/01/stack/</url>
    <content><![CDATA[<h1 id="栈">栈</h1>
<h2 id="背景">背景</h2>
<ul>
<li><p>数据结构——栈</p></li>
<li><p>博主以b站尚硅谷Java数据结构与算法课进行学习</p>
<span id="more"></span></li>
</ul>
<h2 id="介绍">介绍</h2>
<ul>
<li><p>栈是一个<strong>先进后出</strong>的有序列表</p></li>
<li><p>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除一端，为变化的一端，称为<strong>栈顶（Top）</strong>；另一端为固定端，称为<strong>栈底（Bottom）</strong></p></li>
<li><p>先进的元素后删除，后进的元素先删除</p></li>
</ul>
<h2 id="思路">思路</h2>
<ul>
<li><p>使用数组模拟栈</p></li>
<li><p>定义一个<strong>top</strong>来表示栈顶，初始化为-1</p></li>
<li><p>入栈操作，当有数据入栈时，<strong>top++；stack[top] =
data;</strong></p></li>
<li><p>出栈操作，<strong>int value = stack [top];top--,return
value;</strong></p></li>
</ul>
<h2 id="步骤">步骤</h2>
<ul>
<li><p>创建一个测试类ArrayStackDemo</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span><span class="string">" "</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(loop){</span><br><span class="line">            System.out.println(<span class="string">"show:"</span>);</span><br><span class="line">            System.out.println(<span class="string">"exit:"</span>);</span><br><span class="line">            System.out.println(<span class="string">"push:"</span>);</span><br><span class="line">            System.out.println(<span class="string">"pop:"</span>);</span><br><span class="line">            System.out.println(<span class="string">"请输入"</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key){</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入一个数："</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">"出栈的数据是%d\n"</span>,res);</span><br><span class="line">                    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>定义一个ArrayStack类</p>
<ul>
<li><p>栈的大小</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>数组模拟栈，数据放在改数组</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] stack;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>top表示栈顶，初始化为-1</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;   </span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>栈满</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> top == maxSize -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>栈空</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>入栈</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>{</span><br><span class="line">    <span class="comment">//判断栈是否满</span></span><br><span class="line">    <span class="keyword">if</span>(isFull()){</span><br><span class="line">        System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    top++;</span><br><span class="line">    stack[top] = value;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>出栈</p>
<ul>
<li>```java //出栈pop，将栈顶数据返回 public int pop(){ //先判断栈是否空
if(isEmpty()){ //抛出异常 throw new RuntimeException("栈空"); } int
value = stack[top]; top--; return value; } <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 遍历栈</span><br><span class="line"></span><br><span class="line">  * 代码实现</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">    //遍历栈，遍历时要从栈顶开始</span><br><span class="line">       public void list(){</span><br><span class="line">          if(isEmpty()){</span><br><span class="line">              System.out.println("栈空没有数据");</span><br><span class="line">              return;</span><br><span class="line">          }</span><br><span class="line">          //从栈顶开始显示数据</span><br><span class="line">           for(int i=top;i&gt;=0;i--){</span><br><span class="line">               System.out.printf("stack[%d]==%d\n",i,stack[i]);</span><br><span class="line">           }</span><br><span class="line">       }</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
</search>
